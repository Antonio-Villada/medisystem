package medisystem.avanzada.uq.citas_service.dtos.usuario;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UsuarioResponseDTO {

    private Long id;
    private String username;

    // Se mapea el Set<Rol> de la entidad a un Set<String> con los nombres
    private Set<String> roles;

    // ¡Se omite el campo 'password' por seguridad!
}package medisystem.avanzada.uq.citas_service.dtos.usuario;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class UsuarioRequestDTO {

    @NotBlank(message = "El nombre de usuario no puede estar vacío.")
    @Size(min = 4, message = "El nombre de usuario debe tener al menos 4 caracteres.")
    private String username;

    @NotBlank(message = "La contraseña no puede estar vacía.")
    @Size(min = 6, message = "La contraseña debe tener al menos 6 caracteres.")
    private String password;


}package medisystem.avanzada.uq.citas_service.dtos.telefono;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data // Incluye @Getter, @Setter, @ToString, etc.
@NoArgsConstructor
@AllArgsConstructor
public class TelefonoResponseDTO {

    private Long idTelefono; // Coherente con la entidad (Long)
    private String telefono; // El número de teléfono


}package medisystem.avanzada.uq.citas_service.dtos.telefono;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data // Incluye @Getter, @Setter, @ToString, etc.
@NoArgsConstructor
@AllArgsConstructor
public class TelefonoRequestDTO {

    @NotBlank(message = "El número de teléfono no puede estar vacío.")
    @Pattern(regexp = "^[0-9]{7,20}$", message = "El formato del teléfono debe contener solo números (7 a 20 dígitos).")
    private String telefono; // El número de teléfono
}package medisystem.avanzada.uq.citas_service.dtos.paciente;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.Set;


@Data
@NoArgsConstructor
@AllArgsConstructor
public class PacienteResponseDTO {
    private String idPaciente;
    private String nombrePaciente;
    private String ciudad;
    private String correo;
    private String nombreEps;
    private String username;
    private Set<String> telefonos;

}package medisystem.avanzada.uq.citas_service.dtos.paciente;

import jakarta.validation.constraints.*;
import lombok.Data;
import java.util.Set;


@Data
public class PacienteRequestDTO {

    @NotBlank(message = "La identificación (idPaciente) no puede estar vacía.")
    @Size(min = 5, max = 20, message = "La identificación debe tener entre 5 y 20 caracteres.")
    private String idPaciente;

    @NotBlank(message = "El nombre no puede estar vacío.")
    private String nombrePaciente;

    @NotBlank(message = "La ciudad no puede estar vacía.")
    private String ciudad;

    @NotBlank(message = "El correo no puede estar vacío.")
    @Email(message = "Debe ser una dirección de correo válida.")
    private String correo;

    @NotNull(message = "El id de la EPS no puede ser nulo.")
    private Long idEps; // CAMBIADO: Integer -> Long (para coincidir con la Entidad)

    @NotBlank(message = "El nombre de usuario no puede estar vacío.")
    @Size(min = 4, message = "El nombre de usuario debe tener al menos 4 caracteres.")
    private String username;

    @NotBlank(message = "La contraseña no puede estar vacía.")
    @Size(min = 6, message = "La contraseña debe tener al menos 6 caracteres.")
    private String password;

    @NotEmpty(message = "Debe proporcionar al menos un número de teléfono.")
    private Set<String> telefonos;


}package medisystem.avanzada.uq.citas_service.dtos.medico;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class MedicoResponseDTO {

    private Long idMedico;
    private String nombreMedico;
    private String telefono;
    private String correo;

    private String nombreEspecialidad;

    private String username;

    private Set<String> roles;

}package medisystem.avanzada.uq.citas_service.dtos.medico;

import jakarta.validation.constraints.*;
import lombok.Data;

@Data
public class MedicoRequestDTO {

    @NotBlank(message = "El nombre del médico no puede estar vacío.")
    @Size(max = 255, message = "El nombre es demasiado largo.")
    private String nombreMedico;

    @NotNull(message = "Debe especificar el ID de la especialidad.")
    private Long idEspecialidad;

    @NotBlank(message = "El teléfono no puede estar vacío.")
    @Pattern(regexp = "^[0-9]{7,15}$", message = "Formato de teléfono inválido.")
    private String telefono;

    @NotBlank(message = "El correo no puede estar vacío.")
    @Email(message = "Debe ser una dirección de correo válida.")
    private String correo;

    // Campos del Usuario a crear/validar:

    @NotBlank(message = "El nombre de usuario no puede estar vacío.")
    @Size(min = 4, message = "El nombre de usuario debe tener al menos 4 caracteres.")
    private String username;

    @NotBlank(message = "La contraseña no puede estar vacía.")
    @Size(min = 6, message = "La contraseña debe tener al menos 6 caracteres.")
    private String password; // AÑADIDO: Necesario para el registro inicial
}package medisystem.avanzada.uq.citas_service.dtos.medicamento;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.math.BigDecimal; // Importar el tipo de dato correcto

@Data
@NoArgsConstructor
@AllArgsConstructor
public class MedicamentoResponseDTO {

    private Long idMedicamento; // CAMBIADO: Integer -> Long
    private String nombreMedicamento;
    private BigDecimal precio; // CAMBIADO: Integer -> BigDecimal


}package medisystem.avanzada.uq.citas_service.dtos.medicamento;

import jakarta.validation.constraints.*;
import lombok.Data;
import java.math.BigDecimal; // Importar el tipo de dato correcto

@Data // Incluye @Getter, @Setter, @ToString, etc.
public class MedicamentoRequestDTO {

    @NotBlank(message = "El nombre del medicamento no puede estar vacío.")
    @Size(max = 100, message = "El nombre del medicamento es demasiado largo.")
    private String nombreMedicamento;

    @NotNull(message = "El precio no puede estar vacío.")
    @DecimalMin(value = "0.0", inclusive = false, message = "El precio debe ser positivo.")
    private BigDecimal precio; // CAMBIADO: Integer -> BigDecimal (para seguridad financiera)


}package medisystem.avanzada.uq.citas_service.dtos.formula;

import medisystem.avanzada.uq.citas_service.dtos.detalleFormula.DetalleFormulaResponseDTO;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.time.LocalDate;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class FormulaResponseDTO {

    private Long idFormula; // CAMBIADO: Integer -> Long

    // CAMBIO 1: Usamos LocalDate para que Jackson lo serialice correctamente
    private LocalDate fecha;

    // CAMBIO 2: Evitamos el bucle infinito. Solo incluimos el ID de la cita.
    private Long idCita;

    // CAMBIO 3: Incluimos el contenido de la fórmula (la lista de medicamentos)
    private List<DetalleFormulaResponseDTO> detalles;

    // ¡Se eliminaron todos los getters, setters y constructores manuales!
}package medisystem.avanzada.uq.citas_service.dtos.formula;

import jakarta.validation.constraints.NotNull;
import lombok.Data;
import java.time.LocalDate; // Usamos el objeto nativo de Java

@Data
public class FormulaRequestDTO {

    @NotNull(message = "La fecha de la fórmula no puede ser nula.")
    // Jackson se encarga de mapear el String JSON "yyyy-MM-dd" a LocalDate.
    private LocalDate fecha;

    @NotNull(message = "Se requiere el ID de la cita asociada.")
    private Long idCita; // CAMBIADO: Integer -> Long


}package medisystem.avanzada.uq.citas_service.dtos.especialidad;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class EspecialidadResponseDTO {

    private Long idEspecialidad; // Coherente con la entidad (Long)
    private String nombreEspecialidad;


}package medisystem.avanzada.uq.citas_service.dtos.especialidad;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data // Incluye @Getter, @Setter, @ToString, etc.
public class EspecialidadRequestDTO {

    @NotBlank(message = "El nombre de la especialidad no puede estar vacío.")
    @Size(max = 100, message = "El nombre de la especialidad es demasiado largo.")
    private String nombreEspecialidad;

    // ¡No se necesitan getters, setters ni constructores manuales!
}package medisystem.avanzada.uq.citas_service.dtos.eps;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class EpsResponseDTO {

    private Long idEps; // Coherente con la entidad Eps (Long)
    private String nombreEps;

}package medisystem.avanzada.uq.citas_service.dtos.eps;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data // Incluye @Getter, @Setter, @ToString, etc.
public class EpsRequestDTO {

    @NotBlank(message = "El nombre de la EPS no puede estar vacío.")
    @Size(max = 100, message = "El nombre de la EPS es demasiado largo.")
    private String nombreEps;

}package medisystem.avanzada.uq.citas_service.dtos.detalleFormula;

import medisystem.avanzada.uq.citas_service.dtos.medicamento.MedicamentoResponseDTO;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data // Incluye @Getter, @Setter, @ToString, etc.
@NoArgsConstructor
@AllArgsConstructor
public class DetalleFormulaResponseDTO {

    private Long idDetalleFormula; // CAMBIADO: Integer -> Long
    private Integer cantidad;
    private String dosis;

    // CAMBIO 1: ELIMINADO FormulaResponseDTO formula; para evitar el bucle infinito.
    // La fórmula contenedora ya lo sabe.

    // Mantenemos el medicamento anidado (lo cual es bueno).
    private MedicamentoResponseDTO medicamento;

    // ¡Se eliminaron todos los getters, setters y constructores manuales!
} package medisystem.avanzada.uq.citas_service.dtos.detalleFormula;

import jakarta.validation.constraints.*;
import lombok.Data;

@Data
public class DetalleFormulaRequestDTO {

    @NotNull(message = "El ID del medicamento es obligatorio.")
    private Long idMedicamento; // CAMBIADO: Integer -> Long

    @NotNull(message = "La cantidad es obligatoria.")
    @Min(value = 1, message = "La cantidad debe ser al menos 1.")
    private Integer cantidad;

    @NotBlank(message = "La dosis no puede estar vacía.")
    @Size(max = 255, message = "La dosis es demasiado larga.")
    private String dosis;

}package medisystem.avanzada.uq.citas_service.dtos.cita;

import medisystem.avanzada.uq.citas_service.dtos.medico.MedicoResponseDTO;
import medisystem.avanzada.uq.citas_service.dtos.paciente.PacienteResponseDTO;
import medisystem.avanzada.uq.citas_service.dtos.formula.FormulaResponseDTO;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import java.time.LocalDate;
import java.time.LocalTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CitaResponseDTO {

    private Long idCita; // CAMBIADO: Integer -> Long

    // CAMBIADO: String -> LocalDate/LocalTime
    private LocalDate fecha;
    private LocalTime horaInicio;
    private LocalTime horaFin;

    private String observaciones;

    // Relaciones anidadas
    private MedicoResponseDTO medico;
    private PacienteResponseDTO paciente;

    // AÑADIDO: Relación con la fórmula (sin riesgo de bucle)
    private FormulaResponseDTO formula;

}package medisystem.avanzada.uq.citas_service.dtos.cita;

import jakarta.validation.constraints.*;
import lombok.Data;
import java.time.LocalDate;
import java.time.LocalTime;

@Data
public class CitaRequestDTO {

    @NotNull(message = "La fecha no puede ser nula.")
    private LocalDate fecha;       // CAMBIADO: String -> LocalDate

    @NotNull(message = "La hora de inicio no puede ser nula.")
    private LocalTime horaInicio;  // CAMBIADO: String -> LocalTime

    @Size(max = 500, message = "Las observaciones no deben exceder los 500 caracteres.")
    private String observaciones;

    @NotNull(message = "El ID del médico es obligatorio.")
    private Long idMedico;

    @NotBlank(message = "El ID del paciente es obligatorio.")
    private String idPaciente;


}package medisystem.avanzada.uq.citas_service.dtos.auth;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponseDTO {

    private String jwtToken;
    private final String type = "Bearer"; // Estándar de tipo de token

}package medisystem.avanzada.uq.citas_service.dtos.auth;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequestDTO {

    @NotBlank(message = "El nombre de usuario es obligatorio.")
    private String username;

    @NotBlank(message = "La contraseña es obligatoria.")
    private String password;
}package medisystem.avanzada.uq.citas_service.controllers;

import medisystem.avanzada.uq.citas_service.dtos.usuario.UsuarioResponseDTO;
import medisystem.avanzada.uq.citas_service.services.UserService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/usuarios")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    // ==========================================================
    // GET /api/usuarios/perfil : Obtener el perfil del usuario autenticado
    // ==========================================================

    /**
     * Permite a cualquier usuario autenticado ver su propio perfil (sin contraseña).
     * El username se extrae automáticamente del token/sesión de Spring Security.
     */
    @GetMapping("/perfil")
    @PreAuthorize("isAuthenticated()") // Permite cualquier rol que haya iniciado sesión
    public ResponseEntity<UsuarioResponseDTO> getPerfilUsuario() {
        // 1. Obtener el nombre de usuario (username) del contexto de seguridad
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String username = auth.getName();

        // 2. Delegar la búsqueda y mapeo al servicio
        UsuarioResponseDTO perfil = userService.getPerfilUsuario(username);

        return ResponseEntity.ok(perfil);
    }

    // NOTA: Los endpoints de POST (Registro) para Usuarios son delegados a
    // MedicoController y PacienteController, que usan el UserService internamente.

    // Si fuera necesario un endpoint para cambiar la contraseña o actualizar el username,
    // se añadirían métodos PUT/PATCH que interactuarían con el UserService.
}package medisystem.avanzada.uq.citas_service.controllers;

import medisystem.avanzada.uq.citas_service.dtos.paciente.PacienteRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.paciente.PacienteResponseDTO;
import medisystem.avanzada.uq.citas_service.services.PacienteService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;
import java.util.List;

@RestController
@RequestMapping("/pacientes") // Cambiado a /api/pacientes por convención
public class PacienteController {

    private final PacienteService pacienteService;

    public PacienteController(PacienteService pacienteService) {
        this.pacienteService = pacienteService;
    }

    // ==========================================================
    // POST /api/pacientes : Registrar nuevo paciente
    // ==========================================================

    /**
     * Permite al ADMINISTRADOR y al público (si la seguridad lo permite) registrar un nuevo paciente.
     * Utiliza el método registrarPaciente que maneja la lógica de Usuario, EPS y Teléfonos.
     */
    @PostMapping
    @PreAuthorize("hasAnyRole('ADMINISTRADOR')") // Generalmente, el registro inicial está abierto o es para el admin.
    public ResponseEntity<PacienteResponseDTO> registrarPaciente(@Valid @RequestBody PacienteRequestDTO dto) {
        PacienteResponseDTO response = pacienteService.registrarPaciente(dto);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{idPaciente}")
                .buildAndExpand(response.getIdPaciente())
                .toUri();

        return ResponseEntity.created(location).body(response); // Devuelve el DTO de respuesta
    }

    // ==========================================================
    // GET /api/pacientes : Listar todos los pacientes
    // ==========================================================

    /**
     * Solo el ADMINISTRADOR o el MEDICO pueden listar todos los pacientes.
     */
    @GetMapping
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO')")
    public ResponseEntity<List<PacienteResponseDTO>> getAllPacientes() {
        List<PacienteResponseDTO> pacientes = pacienteService.getAllPacientes();
        return ResponseEntity.ok(pacientes);
    }

    // ==========================================================
    // GET /api/pacientes/{idPaciente} : Obtener paciente por ID
    // ==========================================================

    /**
     * Permite a ADMIN, al MEDICO, o al propio PACIENTE (verificación en servicio) consultar el registro.
     */
    @GetMapping("/{idPaciente}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO', 'PACIENTE')")
    public ResponseEntity<PacienteResponseDTO> getPacienteById(@PathVariable String idPaciente) {
        PacienteResponseDTO paciente = pacienteService.getPacienteById(idPaciente);
        return ResponseEntity.ok(paciente);
    }

    // ==========================================================
    // PUT /api/pacientes/{idPaciente} : Actualización total
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR o al propio PACIENTE actualizar totalmente el registro.
     */
    @PutMapping("/{idPaciente}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'PACIENTE')")
    public ResponseEntity<PacienteResponseDTO> putPaciente(@PathVariable String idPaciente,
                                                           @Valid @RequestBody PacienteRequestDTO dto) {
        PacienteResponseDTO actualizado = pacienteService.putPaciente(idPaciente, dto);
        return ResponseEntity.ok(actualizado);
    }

    // ==========================================================
    // PATCH /api/pacientes/{idPaciente} : Actualización parcial
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR o al propio PACIENTE actualizar parcialmente el registro.
     */
    @PatchMapping("/{idPaciente}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'PACIENTE')")
    public ResponseEntity<PacienteResponseDTO> patchPaciente(@PathVariable String idPaciente,
                                                             @RequestBody PacienteRequestDTO dto) {
        PacienteResponseDTO actualizado = pacienteService.patchPaciente(idPaciente, dto);
        return ResponseEntity.ok(actualizado);
    }

    // ==========================================================
    // DELETE /api/pacientes/{idPaciente} : Eliminación
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR eliminar un registro.
     */
    @DeleteMapping("/{idPaciente}")
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    public ResponseEntity<Void> deletePaciente(@PathVariable String idPaciente) {
        pacienteService.deletePaciente(idPaciente);
        return ResponseEntity.noContent().build();
    }
}package medisystem.avanzada.uq.citas_service.controllers;

import medisystem.avanzada.uq.citas_service.dtos.medico.MedicoRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.medico.MedicoResponseDTO;
import medisystem.avanzada.uq.citas_service.services.MedicoService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;
import java.util.List;

@RestController
@RequestMapping("/medicos") // Cambiado a /api/medicos por convención
public class MedicoController {

    private final MedicoService medicoService;

    public MedicoController(MedicoService medicoService) {
        this.medicoService = medicoService;
    }

    // ==========================================================
    // POST /api/medicos : Registrar nuevo médico
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR registrar un nuevo médico.
     * Utiliza el método registrarMedico que crea el Usuario y la Entidad.
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    public ResponseEntity<MedicoResponseDTO> registrarMedico(@Valid @RequestBody MedicoRequestDTO dto) {
        MedicoResponseDTO nuevoMedico = medicoService.registrarMedico(dto);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{idMedico}")
                .buildAndExpand(nuevoMedico.getIdMedico())
                .toUri();

        return ResponseEntity.created(location).body(nuevoMedico); // Devuelve el DTO en el cuerpo
    }

    // ==========================================================
    // GET /api/medicos : Listar todos los médicos
    // ==========================================================

    /**
     * Permite a todos los roles ver la lista de médicos (esencial para agendar citas).
     */
    @GetMapping
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO', 'PACIENTE')")
    public ResponseEntity<List<MedicoResponseDTO>> getAllMedicos() {
        List<MedicoResponseDTO> medicos = medicoService.getAllMedicos();
        return ResponseEntity.ok(medicos);
    }

    // ==========================================================
    // GET /api/medicos/{idMedico} : Obtener médico por ID
    // ==========================================================

    /**
     * Permite a todos consultar un médico específico.
     */
    @GetMapping("/{idMedico}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO', 'PACIENTE')")
    public ResponseEntity<MedicoResponseDTO> getMedicoById(@PathVariable Long idMedico) {
        MedicoResponseDTO medico = medicoService.getMedicoById(idMedico);
        return ResponseEntity.ok(medico);
    }

    // ==========================================================
    // PUT /api/medicos/{idMedico} : Actualización total
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR o al MEDICO que se está editando actualizar totalmente.
     */
    @PutMapping("/{idMedico}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO')") // La lógica de 'solo el propio médico' debe ir en el servicio
    public ResponseEntity<MedicoResponseDTO> updateMedico(@PathVariable Long idMedico,
                                                          @Valid @RequestBody MedicoRequestDTO dto) {
        MedicoResponseDTO actualizado = medicoService.updateMedico(idMedico, dto);
        return ResponseEntity.ok(actualizado);
    }

    // ==========================================================
    // DELETE /api/medicos/{idMedico} : Eliminación
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR eliminar un registro.
     */
    @DeleteMapping("/{idMedico}")
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    public ResponseEntity<Void> deleteMedico(@PathVariable Long idMedico) {
        medicoService.deleteMedico(idMedico);
        return ResponseEntity.noContent().build();
    }

    // ==========================================================
    // PATCH /api/medicos/{idMedico} : Actualización parcial
    // ==========================================================

    /**
     * Permite al ADMINISTRADOR o al MEDICO asociado actualizar parcialmente.
     */
    @PatchMapping("/{idMedico}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO')")
    public ResponseEntity<MedicoResponseDTO> patchMedico(@PathVariable Long idMedico,
                                                         @RequestBody MedicoRequestDTO dto) {
        MedicoResponseDTO actualizado = medicoService.patchMedico(idMedico, dto);
        return ResponseEntity.ok(actualizado);
    }

    // ==========================================================
    // GET /api/medicos/especialidad/{idEspecialidad} : Búsqueda por filtro
    // ==========================================================

    /**
     * Permite a todos ver los médicos filtrados por especialidad.
     */
    @GetMapping("/especialidad/{idEspecialidad}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO', 'PACIENTE')")
    public ResponseEntity<List<MedicoResponseDTO>> getMedicosByEspecialidad(@PathVariable Long idEspecialidad) {
        List<MedicoResponseDTO> medicos = medicoService.getMedicosByEspecialidadId(idEspecialidad);
        return ResponseEntity.ok(medicos);
    }
}package medisystem.avanzada.uq.citas_service.controllers;

import medisystem.avanzada.uq.citas_service.dtos.medicamento.MedicamentoResponseDTO;
import medisystem.avanzada.uq.citas_service.dtos.medicamento.MedicamentoRequestDTO;
import medisystem.avanzada.uq.citas_service.services.MedicamentoService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;
import java.util.List;

@RestController
@RequestMapping("/medicamentos") // Cambiado a /api/medicamentos por convención
public class MedicamentoController {

    private final MedicamentoService medicamentoService;

    public MedicamentoController(MedicamentoService medicamentoService) {
        this.medicamentoService = medicamentoService;
    }

    // ==========================================================
    // GET /api/medicamentos : Listar todos los medicamentos
    // ==========================================================

    /**
     * Permite a Médicos y Administradores consultar el catálogo (necesario para formular).
     */
    @GetMapping
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO')")
    public ResponseEntity<List<MedicamentoResponseDTO>> getMedicamentos() {
        List<MedicamentoResponseDTO> medicamentos = medicamentoService.getMedicamentos();
        return ResponseEntity.ok(medicamentos);
    }

    // ==========================================================
    // GET /api/medicamentos/{idMedicamento} : Obtener medicamento por ID
    // ==========================================================

    /**
     * Permite a Médicos y Administradores consultar un medicamento específico.
     */
    @GetMapping("/{idMedicamento}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO')")
    // CORREGIDO: Integer -> Long
    public ResponseEntity<MedicamentoResponseDTO> getMedicamentoById(@PathVariable Long idMedicamento) {
        MedicamentoResponseDTO medicamento = medicamentoService.getMedicamentoById(idMedicamento);
        return ResponseEntity.ok(medicamento);
    }

    // ==========================================================
    // POST /api/medicamentos : Crear nuevo medicamento
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR crear un nuevo medicamento.
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    public ResponseEntity<MedicamentoResponseDTO> postMedicamento(@Valid @RequestBody MedicamentoRequestDTO medicamento) {
        MedicamentoResponseDTO nuevo = medicamentoService.postMedicamento(medicamento);

        URI location = ServletUriComponentsBuilder.fromCurrentRequest()
                .path("/{idMedicamento}")
                .buildAndExpand(nuevo.getIdMedicamento())
                .toUri();

        return ResponseEntity.created(location).body(nuevo); // Devuelve el DTO en el cuerpo
    }

    // ==========================================================
    // PUT /api/medicamentos/{idMedicamento} : Actualización total
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR actualizar totalmente un medicamento.
     */
    @PutMapping("/{idMedicamento}")
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    // CORREGIDO: Integer -> Long
    public ResponseEntity<MedicamentoResponseDTO> putMedicamento(@PathVariable Long idMedicamento,
                                                                 @Valid @RequestBody MedicamentoRequestDTO medicamento) {
        MedicamentoResponseDTO actualizado = medicamentoService.putMedicamento(idMedicamento, medicamento);
        return ResponseEntity.ok(actualizado);
    }

    // ==========================================================
    // DELETE /api/medicamentos/{idMedicamento} : Eliminación
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR eliminar un medicamento.
     */
    @DeleteMapping("/{idMedicamento}")
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    // CORREGIDO: Integer -> Long
    public ResponseEntity<Void> deleteMedicamento(@PathVariable Long idMedicamento) {
        medicamentoService.deleteMedicamento(idMedicamento);
        return ResponseEntity.noContent().build();
    }

    // ==========================================================
    // PATCH /api/medicamentos/{idMedicamento} : Actualización parcial
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR actualizar parcialmente un medicamento.
     */
    @PatchMapping("/{idMedicamento}")
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    // CORREGIDO: Integer -> Long
    public ResponseEntity<MedicamentoResponseDTO> patchMedicamento(@PathVariable Long idMedicamento,
                                                                   @RequestBody MedicamentoRequestDTO medicamento) {
        MedicamentoResponseDTO actualizado = medicamentoService.patchMedicamento(idMedicamento, medicamento);
        return ResponseEntity.ok(actualizado);
    }
}package medisystem.avanzada.uq.citas_service.controllers;

import medisystem.avanzada.uq.citas_service.dtos.formula.FormulaRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.formula.FormulaResponseDTO;
import medisystem.avanzada.uq.citas_service.services.FormulaService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;
import java.util.List;

@RestController
@RequestMapping("/formulas") // Usamos la convención /api/
public class FormulaController {

    private final FormulaService formulaService;

    public FormulaController(FormulaService formulaService) {
        this.formulaService = formulaService;
    }

    // ==========================================================
    // GET /api/formulas : Listar todas
    // ==========================================================

    /**
     * Permite a Administradores y Médicos listar todas las fórmulas.
     */
    @GetMapping
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO')")
    public ResponseEntity<List<FormulaResponseDTO>> findAll() {
        return ResponseEntity.ok(formulaService.findAll());
    }

    // ==========================================================
    // GET /api/formulas/{id} : Obtener por ID
    // ==========================================================

    /**
     * Permite a Administradores, el Médico que la creó y el Paciente asociado ver la fórmula.
     * La verificación de acceso se maneja en FormulaServiceImpl.
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO', 'PACIENTE')")
    // CORREGIDO: int -> Long
    public ResponseEntity<FormulaResponseDTO> findById(@PathVariable Long id) {
        return ResponseEntity.ok(formulaService.findById(id));
    }

    // ==========================================================
    // POST /api/formulas : Crear
    // ==========================================================

    /**
     * Permite solo al MÉDICO crear una nueva fórmula para una cita.
     * Se requiere que la cita no tenga fórmula y que el médico autenticado sea el de la cita.
     */
    @PostMapping
    @PreAuthorize("hasRole('MEDICO')")
    public ResponseEntity<FormulaResponseDTO> create(@Valid @RequestBody FormulaRequestDTO formulaRequest) {
        FormulaResponseDTO nueva = formulaService.save(formulaRequest);

        URI location = ServletUriComponentsBuilder.fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(nueva.getIdFormula())
                .toUri();

        // Devolvemos el DTO en el cuerpo (Created 201)
        return ResponseEntity.created(location).body(nueva);
    }

    // ==========================================================
    // PUT /api/formulas/{id} : Actualización total (Fecha/Detalles)
    // ==========================================================

    /**
     * Permite solo al MÉDICO que creó la fórmula actualizarla.
     * La verificación de autoría se realiza en FormulaServiceImpl.
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('MEDICO')")
    // CORREGIDO: int -> Long, Formula -> FormulaRequestDTO
    public ResponseEntity<FormulaResponseDTO> update(@PathVariable Long id,
                                                     @Valid @RequestBody FormulaRequestDTO dto) {
        FormulaResponseDTO actualizado = formulaService.update(id, dto);
        return ResponseEntity.ok(actualizado);
    }

    // ==========================================================
    // DELETE /api/formulas/{id} : Eliminación
    // ==========================================================

    /**
     * Permite solo al MÉDICO que creó la fórmula o al ADMINISTRADOR eliminarla.
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO')")
    // CORREGIDO: int -> Long
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        formulaService.delete(id);
        return ResponseEntity.noContent().build();
    }
}package medisystem.avanzada.uq.citas_service.controllers;

import medisystem.avanzada.uq.citas_service.dtos.especialidad.EspecialidadRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.especialidad.EspecialidadResponseDTO;
import medisystem.avanzada.uq.citas_service.services.EspecialidadService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;
import java.util.List;


@RestController
@RequestMapping("/especialidades") // Cambiado a /api/especialidades por convención
public class EspecialidadController {

    private final EspecialidadService especialidadService;

    // Inyección por constructor
    public EspecialidadController(EspecialidadService especialidadService) {
        this.especialidadService = especialidadService;
    }

    // ==========================================================
    // GET /api/especialidades : Listar todas las Especialidades
    // ==========================================================

    /**
     * Permite a todos los roles consultar las especialidades (necesario para registro de Médicos).
     */
    @GetMapping
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO', 'PACIENTE')")
    public ResponseEntity<List<EspecialidadResponseDTO>> getAllEspecialidades(){
        List<EspecialidadResponseDTO> especialidades = especialidadService.getAllEspecialidades();
        return ResponseEntity.ok(especialidades);
    }

    // ==========================================================
    // GET /api/especialidades/{idEspecialidad} : Obtener por ID
    // ==========================================================

    /**
     * Permite a todos consultar una especialidad específica.
     */
    @GetMapping("/{idEspecialidad}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO', 'PACIENTE')")
    public ResponseEntity<EspecialidadResponseDTO> getEspecialidadById(@PathVariable Long idEspecialidad){
        EspecialidadResponseDTO especialidad = especialidadService.getEspecialidadById(idEspecialidad);
        return ResponseEntity.ok(especialidad);
    }

    // ==========================================================
    // POST /api/especialidades : Crear nueva Especialidad
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR crear una nueva especialidad.
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    public ResponseEntity<EspecialidadResponseDTO> postEspecialidad(@Valid @RequestBody EspecialidadRequestDTO dto){
        EspecialidadResponseDTO nuevaEspecialidad = especialidadService.postEspecialidad(dto);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{idEspecialidad}")
                .buildAndExpand(nuevaEspecialidad.getIdEspecialidad())
                .toUri();

        return ResponseEntity.created(location).body(nuevaEspecialidad);
    }

    // ==========================================================
    // PUT /api/especialidades/{idEspecialidad} : Actualización total
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR actualizar totalmente una especialidad.
     */
    @PutMapping("/{idEspecialidad}")
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    public ResponseEntity<EspecialidadResponseDTO> putEspecialidad(@PathVariable Long idEspecialidad,
                                                                   @Valid @RequestBody EspecialidadRequestDTO dto){
        EspecialidadResponseDTO actualizado = especialidadService.putEspecialidad(idEspecialidad, dto);
        return ResponseEntity.ok(actualizado);
    }

    // ==========================================================
    // DELETE /api/especialidades/{idEspecialidad} : Eliminación
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR eliminar una especialidad.
     */
    @DeleteMapping("/{idEspecialidad}")
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    public ResponseEntity<Void> deleteEspecialidad(@PathVariable Long idEspecialidad){
        especialidadService.deleteEspecialidad(idEspecialidad);
        return ResponseEntity.noContent().build();
    }

    // ==========================================================
    // PATCH /api/especialidades/{idEspecialidad} : Actualización parcial
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR actualizar parcialmente una especialidad.
     */
    @PatchMapping("/{idEspecialidad}")
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    public ResponseEntity<EspecialidadResponseDTO> patchEspecialidad(@PathVariable Long idEspecialidad,
                                                                     @RequestBody EspecialidadRequestDTO dto){
        EspecialidadResponseDTO actualizado = especialidadService.patchEspecialidad(idEspecialidad, dto);
        return ResponseEntity.ok(actualizado);
    }
}package medisystem.avanzada.uq.citas_service.controllers;

import medisystem.avanzada.uq.citas_service.dtos.eps.EpsRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.eps.EpsResponseDTO;
import medisystem.avanzada.uq.citas_service.services.EpsService;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;
import java.util.List;

@RestController
@RequestMapping("/eps") // Cambiado a /api/eps por convención
public class EpsController {

    private final EpsService epsService;

    public EpsController(EpsService epsService) {
        this.epsService = epsService;
    }

    // ==========================================================
    // GET /api/eps : Listar todas las EPS
    // ==========================================================

    /**
     * Permite a todos los roles consultar las EPS (necesario para el registro de Pacientes).
     */
    @GetMapping
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO', 'PACIENTE')")
    public ResponseEntity<List<EpsResponseDTO>> getAllEps() {
        List<EpsResponseDTO> eps = epsService.getAllEps();
        return ResponseEntity.ok(eps);
    }

    // ==========================================================
    // GET /api/eps/{idEps} : Obtener EPS por ID
    // ==========================================================

    /**
     * Permite a todos consultar una EPS específica.
     */
    @GetMapping("/{idEps}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO', 'PACIENTE')")
    // CORREGIDO: int -> Long
    public ResponseEntity<EpsResponseDTO> getEpsById(@PathVariable Long idEps) {
        EpsResponseDTO eps = epsService.getEpsById(idEps);
        return ResponseEntity.ok(eps);
    }

    // ==========================================================
    // POST /api/eps : Crear nueva EPS
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR crear una nueva EPS.
     */
    @PostMapping
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    // CORREGIDO: Eps -> EpsRequestDTO y devuelve EpsResponseDTO
    public ResponseEntity<EpsResponseDTO> postEps(@Valid @RequestBody EpsRequestDTO dto){
        EpsResponseDTO nuevaEps = epsService.postEps(dto);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{idEps}")
                .buildAndExpand(nuevaEps.getIdEps())
                .toUri();

        return ResponseEntity.created(location).body(nuevaEps); // Devuelve el DTO
    }

    // ==========================================================
    // PUT /api/eps/{idEps} : Actualización total
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR actualizar totalmente una EPS.
     */
    @PutMapping("/{idEps}")
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    // CORREGIDO: int -> Long, Eps -> EpsRequestDTO y devuelve EpsResponseDTO
    public ResponseEntity<EpsResponseDTO> putEps(@PathVariable Long idEps,
                                                 @Valid @RequestBody EpsRequestDTO dto){
        EpsResponseDTO actualizado = epsService.putEps(idEps, dto);
        return ResponseEntity.ok(actualizado);
    }

    // ==========================================================
    // DELETE /api/eps/{idEps} : Eliminación
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR eliminar una EPS.
     */
    @DeleteMapping("/{idEps}")
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    // CORREGIDO: int -> Long
    public ResponseEntity<Void> deleteEps(@PathVariable Long idEps) {
        epsService.deleteEps(idEps);
        return ResponseEntity.noContent().build();
    }

    // ==========================================================
    // PATCH /api/eps/{idEps} : Actualización parcial
    // ==========================================================

    /**
     * Permite solo al ADMINISTRADOR actualizar parcialmente una EPS.
     */
    @PatchMapping("/{idEps}")
    @PreAuthorize("hasRole('ADMINISTRADOR')")
    // CORREGIDO: int -> Long, Eps -> EpsRequestDTO y devuelve EpsResponseDTO
    public ResponseEntity<EpsResponseDTO> patchEps(@PathVariable Long idEps,
                                                   @RequestBody EpsRequestDTO dto) {
        EpsResponseDTO actualizado = epsService.patchEps(idEps, dto);
        return ResponseEntity.ok(actualizado);
    }
}package medisystem.avanzada.uq.citas_service.controllers;

import medisystem.avanzada.uq.citas_service.dtos.cita.CitaRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.cita.CitaResponseDTO;
import medisystem.avanzada.uq.citas_service.services.CitaService;
import medisystem.avanzada.uq.citas_service.entities.Medico;
import medisystem.avanzada.uq.citas_service.entities.Paciente;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/citas")
public class CitaController {

    private final CitaService citaService;

    public CitaController(CitaService citaService) {
        this.citaService = citaService;
    }

    // ==========================================================
    // POST /api/citas : Agendar nueva cita
    // ==========================================================

    /**
     * Permite a un PACIENTE agendar una cita.
     * @param dto Contiene fecha, hora, idMedico e idPaciente.
     */
    @PostMapping
    @PreAuthorize("hasRole('PACIENTE')")
    public ResponseEntity<CitaResponseDTO> agendarCita(@Valid @RequestBody CitaRequestDTO dto) {
        CitaResponseDTO nuevaCita = citaService.agendarCita(dto);
        return ResponseEntity.status(HttpStatus.CREATED).body(nuevaCita);
    }

    // ==========================================================
    // GET /api/citas : Obtener todas las citas (ADMIN)
    // ==========================================================

    /**
     * Permite a ADMIN ver todas las citas. PACIENTE/MEDICO ven las suyas (lógica en servicio/security).
     */
    @GetMapping
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO', 'PACIENTE')")
    public ResponseEntity<List<CitaResponseDTO>> getAllCitas() {
        // La lógica de filtrado por rol se maneja en el CitaServiceImpl.
        List<CitaResponseDTO> citas = citaService.getAllCitas();
        return ResponseEntity.ok(citas);
    }

    // ==========================================================
    // GET /api/citas/{id} : Obtener una cita por ID
    // ==========================================================

    /**
     * Permite a ADMIN, el PACIENTE o el MEDICO asociado ver la cita.
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO', 'PACIENTE')")
    public ResponseEntity<CitaResponseDTO> getCitaById(@PathVariable Long id) {
        CitaResponseDTO cita = citaService.getCitaById(id);
        return ResponseEntity.ok(cita);
    }

    // ==========================================================
    // GET /api/citas/paciente/{idPaciente} : Historial de citas por paciente
    // NOTA: Requiere que el método en el servicio reciba la Entidad Paciente
    // o que se cambie la firma del método en el servicio.
    // ==========================================================
    
    /* * NOTA: Este método está comentado porque la implementación del servicio 
     * lo requiere con la Entidad Paciente, lo cual no es ideal en el Controller.
     * Si usas la versión con ID, debes cambiar la interfaz CitaService.
    @GetMapping("/paciente/{idPaciente}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'PACIENTE')")
    public ResponseEntity<List<CitaResponseDTO>> getCitasByPaciente(@PathVariable String idPaciente) {
        // En un Controller, deberías buscar la Entidad Paciente aquí si el servicio lo requiere, o
        // cambiar el servicio para que acepte String idPaciente.
        // Asumiendo que el servicio fue corregido para usar ID, se usaría:
        // List<CitaResponseDTO> citas = citaService.getCitasByPacienteId(idPaciente); 
        // return ResponseEntity.ok(citas);
    }
    */


    // ==========================================================
    // PUT /api/citas/{id} : Actualización total de la cita
    // ==========================================================

    /**
     * Permite a ADMIN o el MEDICO asociado actualizar los datos de la cita.
     */
    @PutMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO')")
    public ResponseEntity<CitaResponseDTO> updateCita(@PathVariable Long id,
                                                      @Valid @RequestBody CitaRequestDTO dto) {
        CitaResponseDTO updatedCita = citaService.updateCita(id, dto);
        return ResponseEntity.ok(updatedCita);
    }

    // ==========================================================
    // PATCH /api/citas/{id} : Actualización parcial de la cita
    // ==========================================================

    /**
     * Permite a ADMIN o el MEDICO asociado actualizar parcialmente los datos.
     */
    @PatchMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO')")
    public ResponseEntity<CitaResponseDTO> patchCita(@PathVariable Long id,
                                                     @RequestBody CitaRequestDTO dto) {
        CitaResponseDTO updatedCita = citaService.patchCita(id, dto);
        return ResponseEntity.ok(updatedCita);
    }

    // ==========================================================
    // DELETE /api/citas/{id} : Cancelar cita
    // ==========================================================

    /**
     * Permite a ADMIN, el MEDICO o el PACIENTE asociado cancelar la cita.
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMINISTRADOR', 'MEDICO', 'PACIENTE')")
    public ResponseEntity<Void> deleteCita(@PathVariable Long id) {
        citaService.deleteCita(id);
        return ResponseEntity.noContent().build();
    }
}package medisystem.avanzada.uq.citas_service.mappers;

import medisystem.avanzada.uq.citas_service.dtos.usuario.UsuarioResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Usuario;
import medisystem.avanzada.uq.citas_service.entities.Rol; // Necesario para el método de ayuda

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;

import java.util.Set;
import java.util.stream.Collectors;

// Indicamos que es un componente de Spring
@Mapper(componentModel = "spring")
public interface UsuarioMapper {

    // --------------------------------------------------------------------
    // 1. ENTITY a RESPONSE DTO (Lectura de perfil/Login)
    // --------------------------------------------------------------------

    /**
     * Mapea la Entidad Usuario a UsuarioResponseDTO.
     * Mapea automáticamente 'id' y 'username'.
     * Utiliza el método de ayuda para mapear los roles.
     * La contraseña se omite por defecto ya que no existe en el DTO.
     */
    @Mapping(target = "roles", source = "usuario.roles", qualifiedByName = "rolesToStringSet")
    UsuarioResponseDTO toResponseDTO(Usuario usuario);


    // --------------------------------------------------------------------
    // 2. Método de Ayuda para Mapeo Complejo (Set<Rol> a Set<String>)
    // --------------------------------------------------------------------

    /**
     * Convierte el Set<Rol> del Usuario en un Set<String> con los nombres de los roles.
     * Este método es idéntico al que usaríamos en MedicoMapper.
     */
    @Named("rolesToStringSet")
    default Set<String> rolesToStringSet(Set<Rol> roles) {
        if (roles == null) {
            return Set.of();
        }
        return roles.stream()
                .map(rol -> rol.getNombre().name()) // Convierte el Enum RolNombre a su String
                .collect(Collectors.toSet());
    }
}package medisystem.avanzada.uq.citas_service.mappers;

import medisystem.avanzada.uq.citas_service.dtos.telefono.TelefonoRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.telefono.TelefonoResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Telefono;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface TelefonoMapper {

    // --------------------------------------------------------------------
    // 1. DTO a ENTITY (Creación)
    // --------------------------------------------------------------------

    /**
     * Mapea TelefonoRequestDTO a Telefono.
     * El campo 'telefono' se mapea automáticamente.
     * Ignoramos el ID ya que es autogenerado.
     */
    @Mapping(target = "idTelefono", ignore = true)
    Telefono toEntity(TelefonoRequestDTO dto);


    // --------------------------------------------------------------------
    // 2. ENTITY a RESPONSE DTO (Lectura)
    // --------------------------------------------------------------------

    /**
     * Mapea la Entidad Telefono a TelefonoResponseDTO.
     * Ambos campos tienen el mismo nombre y se mapean automáticamente.
     */
    TelefonoResponseDTO toResponseDTO(Telefono entity);
}package medisystem.avanzada.uq.citas_service.mappers;

import medisystem.avanzada.uq.citas_service.dtos.paciente.PacienteRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.paciente.PacienteResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Eps;
import medisystem.avanzada.uq.citas_service.entities.Paciente;
import medisystem.avanzada.uq.citas_service.entities.PacienteTelefono;
import medisystem.avanzada.uq.citas_service.entities.Usuario;
import medisystem.avanzada.uq.citas_service.entities.Telefono;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Mapper(componentModel = "spring")
public interface PacienteMapper {

    @Mapping(target = "eps", source = "eps")
    @Mapping(target = "usuario", source = "usuario")
    @Mapping(target = "telefonos", ignore = true)
    @Mapping(target = "idPaciente", ignore = true)
    Paciente toEntity(PacienteRequestDTO dto, Eps eps, Usuario usuario);

    @Mapping(target = "nombreEps", source = "paciente.eps.nombreEps")
    @Mapping(target = "username", source = "paciente.usuario.username")
    @Mapping(target = "telefonos", source = "paciente.telefonos", qualifiedByName = "telefonosToStringSet")
    PacienteResponseDTO toResponseDTO(Paciente paciente);

    /**
     * MÉTODO SOBRECARGADO para usar en servicios (POST/PUT/PATCH)
     * donde la lista de teléfonos ya fue procesada en el servicio.
     */
    @Mapping(target = "nombreEps", source = "paciente.eps.nombreEps")
    @Mapping(target = "username", source = "paciente.usuario.username")
    @Mapping(target = "telefonos", source = "telefonos") // Mapea el Set<String> directo
    PacienteResponseDTO toResponseDTO(Paciente paciente, Set<String> telefonos);


    @Named("telefonosToStringSet")
    default Set<String> telefonosToStringSet(List<PacienteTelefono> telefonos) {
        if (telefonos == null || telefonos.isEmpty()) {
            return Set.of();
        }

        // Esta línea es correcta si la entidad PacienteTelefono tiene el campo 'telefono'
        // y este campo es de tipo Telefono, y Telefono tiene un getTelefono().
        return telefonos.stream()
                .map(pt -> pt.getTelefono().getTelefono())
                .collect(Collectors.toSet());
    }
}package medisystem.avanzada.uq.citas_service.mappers;

import medisystem.avanzada.uq.citas_service.dtos.medico.MedicoRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.medico.MedicoResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Medico;
import medisystem.avanzada.uq.citas_service.entities.Especialidad;
import medisystem.avanzada.uq.citas_service.entities.Usuario;
import medisystem.avanzada.uq.citas_service.entities.Rol; // Necesario para el método de ayuda

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;
import java.util.Set;
import java.util.stream.Collectors;

@Mapper(componentModel = "spring")
public interface MedicoMapper {


    // DTO a ENTITY (Creación/Actualización)

    /**
     * Mapea MedicoRequestDTO a Medico.
     * El servicio es responsable de obtener/crear 'usuario' y 'especialidad' y pasarlos como argumentos.
     */
    @Mapping(target = "especialidad", source = "especialidad") // Mapea el objeto Especialidad
    @Mapping(target = "usuario", source = "usuario")           // Mapea el objeto Usuario
    @Mapping(target = "idMedico", ignore = true)               // El ID es autogenerado por la BD (ignoramos el source del DTO)
    Medico toEntity(MedicoRequestDTO dto, Usuario usuario, Especialidad especialidad);


    // ENTITY a RESPONSE DTO (Lectura)
    /**
     * Mapea la Entidad Medico a MedicoResponseDTO.
     */
    @Mapping(target = "nombreEspecialidad", source = "medico.especialidad.nombreEspecialidad") // Obtiene el nombre
    @Mapping(target = "username", source = "medico.usuario.username")                       // Obtiene el username
    @Mapping(target = "roles", source = "medico.usuario.roles", qualifiedByName = "rolesToStringSet") // Usa el método de ayuda
    MedicoResponseDTO toResponseDTO(Medico medico);


    //  Método de Ayuda para Mapeo Complejo (Set<Rol> a Set<String>)

    /**
     * Convierte el Set<Rol> del Usuario en un Set<String> con los nombres de los roles.
     * Este método reemplaza la lógica manual que tenías para extraer el rol.
     */
    @Named("rolesToStringSet")
    default Set<String> rolesToStringSet(Set<Rol> roles) {
        if (roles == null) {
            return Set.of();
        }
        return roles.stream()
                .map(rol -> rol.getNombre().name()) // Convierte el Enum RolNombre a su String
                .collect(Collectors.toSet());
    }
}package medisystem.avanzada.uq.citas_service.mappers;

import medisystem.avanzada.uq.citas_service.dtos.medicamento.MedicamentoRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.medicamento.MedicamentoResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Medicamento;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

// Indicamos que es un componente de Spring y que use el model 'spring'
@Mapper(componentModel = "spring")
public interface MedicamentoMapper {

    // --------------------------------------------------------------------
    // 1. DTO a ENTITY (Creación)
    // --------------------------------------------------------------------

    /**
     * Mapea MedicamentoRequestDTO a Medicamento.
     * Los campos 'nombreMedicamento' y 'precio' se mapean automáticamente.
     * Ignoramos el ID ya que es autogenerado.
     */
    @Mapping(target = "idMedicamento", ignore = true)
    Medicamento toEntity(MedicamentoRequestDTO dto);


    // --------------------------------------------------------------------
    // 2. ENTITY a RESPONSE DTO (Lectura)
    // --------------------------------------------------------------------

    /**
     * Mapea la Entidad Medicamento a MedicamentoResponseDTO.
     * Todos los campos tienen el mismo nombre y se mapean automáticamente.
     */
    MedicamentoResponseDTO toResponseDTO(Medicamento entity);
}package medisystem.avanzada.uq.citas_service.mappers;

import medisystem.avanzada.uq.citas_service.dtos.formula.FormulaRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.formula.FormulaResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Cita;
import medisystem.avanzada.uq.citas_service.entities.Formula;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

// Asegúrate de que este mapper conoce los mappers que necesitará
@Mapper(componentModel = "spring", uses = {DetalleFormulaMapper.class})
public interface FormulaMapper {

    // --------------------------------------------------------------------
    // 1. DTO a ENTITY (Creación)
    // --------------------------------------------------------------------

    /**
     * Mapea FormulaRequestDTO a Formula.
     */
    @Mapping(target = "cita", source = "cita")
    @Mapping(target = "idFormula", ignore = true) // El ID es autogenerado
    // La lista de detalles se ignoran y se manejan en el servicio después de la creación
    @Mapping(target = "detalles", ignore = true)

    // CORRECCIÓN: Resuelve la ambigüedad indicando que 'fecha' viene del 'dto'
    @Mapping(target = "fecha", source = "dto.fecha")
    Formula toEntity(FormulaRequestDTO dto, Cita cita);


    // --------------------------------------------------------------------
    // 2. ENTITY a RESPONSE DTO (Lectura)
    // --------------------------------------------------------------------

    /**
     * Mapea la Entidad Formula a FormulaResponseDTO.
     *
     * MapStruct usa el DetalleFormulaMapper (definido en 'uses') para la lista 'detalles'.
     */

    // Mapeo del idCita (aplanamos la relación inversa para evitar el bucle)
    @Mapping(target = "idCita", source = "formula.cita.idCita")

    // Mapeo de la lista de detalles (ahora que la propiedad 'detalles' existe en la Entidad Formula)
    @Mapping(target = "detalles", source = "formula.detalles")

    // El mapeo de 'fecha' y 'idFormula' es implícito.
    FormulaResponseDTO toResponseDTO(Formula formula);
}package medisystem.avanzada.uq.citas_service.mappers;

import medisystem.avanzada.uq.citas_service.dtos.especialidad.EspecialidadRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.especialidad.EspecialidadResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Especialidad;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface EspecialidadMapper {

    // --------------------------------------------------------------------
    // 1. DTO a ENTITY (Creación)
    // --------------------------------------------------------------------

    /**
     * Mapea EspecialidadRequestDTO a Especialidad.
     * El campo 'nombreEspecialidad' se mapea automáticamente.
     * Ignoramos el ID ya que es autogenerado.
     */
    @Mapping(target = "idEspecialidad", ignore = true)
    Especialidad toEntity(EspecialidadRequestDTO dto);


    // --------------------------------------------------------------------
    // 2. ENTITY a RESPONSE DTO (Lectura)
    // --------------------------------------------------------------------

    /**
     * Mapea la Entidad Especialidad a EspecialidadResponseDTO.
     * Ambos campos (idEspecialidad y nombreEspecialidad) tienen el mismo nombre
     * y se mapean automáticamente.
     */
    EspecialidadResponseDTO toResponseDTO(Especialidad entity);
}package medisystem.avanzada.uq.citas_service.mappers;

import medisystem.avanzada.uq.citas_service.dtos.eps.EpsRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.eps.EpsResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Eps;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface EpsMapper {

    // --------------------------------------------------------------------
    // 1. DTO a ENTITY (Creación)
    // --------------------------------------------------------------------

    /**
     * Mapea EpsRequestDTO a Eps.
     * El campo 'nombreEps' se mapea automáticamente.
     * Ignoramos el ID ya que es autogenerado.
     */
    @Mapping(target = "idEps", ignore = true)
    Eps toEntity(EpsRequestDTO dto);


    // --------------------------------------------------------------------
    // 2. ENTITY a RESPONSE DTO (Lectura)
    // --------------------------------------------------------------------

    /**
     * Mapea la Entidad Eps a EpsResponseDTO.
     * Ambos campos (idEps y nombreEps) tienen el mismo nombre y se mapean automáticamente.
     */
    EpsResponseDTO toResponseDTO(Eps entity);
}package medisystem.avanzada.uq.citas_service.mappers;

import medisystem.avanzada.uq.citas_service.dtos.detalleFormula.DetalleFormulaRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.detalleFormula.DetalleFormulaResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.DetalleFormula;
import medisystem.avanzada.uq.citas_service.entities.Formula;
import medisystem.avanzada.uq.citas_service.entities.Medicamento;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

// Indicamos que use el MedicamentoMapper para mapear el objeto Medicamento
@Mapper(componentModel = "spring", uses = {MedicamentoMapper.class})
public interface DetalleFormulaMapper {

    // --------------------------------------------------------------------
    // 1. DTO a ENTITY (Creación)
    // --------------------------------------------------------------------

    /**
     * Mapea DetalleFormulaRequestDTO a DetalleFormula.
     */
    @Mapping(target = "formula", source = "formula")
    @Mapping(target = "medicamento", source = "medicamento")
    @Mapping(target = "idDetalleFormula", ignore = true)
    DetalleFormula toEntity(DetalleFormulaRequestDTO dto, Formula formula, Medicamento medicamento);


    // --------------------------------------------------------------------
    // 2. ENTITY a RESPONSE DTO (Lectura)
    // --------------------------------------------------------------------

    /**
     * Mapea la Entidad DetalleFormula a DetalleFormulaResponseDTO.
     *
     * Se elimina el mapeo/ignorancia de 'formula' ya que el campo no existe en el DTO.
     * Los mapeos idDetalleFormula, cantidad y dosis son implícitos.
     */

    // Ya que DetalleFormulaResponseDTO no tiene un campo 'formula', no es necesario ignorarlo.
    // Solo mapeamos el medicamento
    @Mapping(target = "medicamento", source = "entity.medicamento")

    // Si quisieras el ID de la fórmula, lo agregarías al DTO y lo mapearías así:
    // @Mapping(target = "idFormula", source = "entity.formula.idFormula")

    DetalleFormulaResponseDTO toResponseDTO(DetalleFormula entity);
}package medisystem.avanzada.uq.citas_service.mappers;

import medisystem.avanzada.uq.citas_service.dtos.cita.CitaRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.cita.CitaResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Cita;
import medisystem.avanzada.uq.citas_service.entities.Medico;
import medisystem.avanzada.uq.citas_service.entities.Paciente;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;



// Indicamos que use otros mappers para anidar los objetos DTO
@Mapper(componentModel = "spring", uses = {MedicoMapper.class, PacienteMapper.class, FormulaMapper.class})
public interface CitaMapper {

    // --------------------------------------------------------------------
    // 1. DTO a ENTITY (Creación)
    // --------------------------------------------------------------------

    /**
     * Mapea CitaRequestDTO a Cita.
     *
     * MapStruct se encarga automáticamente de:
     * - fecha (LocalDate a LocalDate)
     * - horaInicio (LocalTime a LocalTime)
     * - observaciones
     *
     * El servicio pasa las entidades Medico y Paciente.
     */
    @Mapping(target = "medico", source = "medico")
    @Mapping(target = "paciente", source = "paciente")

    // horaFin se calcula con el ciclo de vida (@PrePersist) en la entidad Cita.
    // Lo ignoramos para evitar que MapStruct intente mapear un valor nulo.
    @Mapping(target = "horaFin", ignore = true)

    @Mapping(target = "idCita", ignore = true) // El ID es autogenerado.
    @Mapping(target = "formula", ignore = true) // La fórmula se crea después, no en el request
    Cita toEntity(CitaRequestDTO dto, Medico medico, Paciente paciente);


    // --------------------------------------------------------------------
    // 2. ENTITY a RESPONSE DTO (Lectura)
    // --------------------------------------------------------------------

    /**
     * Mapea la Entidad Cita a CitaResponseDTO.
     *
     * MapStruct usa los mappers definidos en 'uses' para anidar:
     * - medico (llama a MedicoMapper.toResponseDTO)
     * - paciente (llama a PacienteMapper.toResponseDTO)
     * - formula (llama a FormulaMapper.toResponseDTO)
     */

    // Los DTOs ya están correctos (Long, LocalDate, LocalTime), por lo que mapean directamente.
    @Mapping(target = "medico", source = "cita.medico")
    @Mapping(target = "paciente", source = "cita.paciente")
    @Mapping(target = "formula", source = "cita.formula") // Usa el FormulaMapper
    CitaResponseDTO toResponseDTO(Cita cita);
}package medisystem.avanzada.uq.citas_service.exceptions;

public final class UsuarioYaExisteException extends RuntimeException {

    // 1. Constructor simple con mensaje (mantenido por flexibilidad)
    public UsuarioYaExisteException(String mensaje) {
        super(mensaje);
    }

    // 2. Constructor que envuelve otra excepción (para debug)
    public UsuarioYaExisteException(String mensaje, Throwable causa) {
        super(mensaje, causa);
    }

    // 3. Constructor especializado para indicar que el username ya existe (el más común).
    public UsuarioYaExisteException(String username, boolean porUsername) {
        // Usamos un flag booleano dummy para diferenciar del constructor simple (String mensaje).
        super("El nombre de usuario '" + username + "' ya está registrado en el sistema.");
    }

    // 4. Constructor especializado para indicar que el ID de usuario ya existe (menos común, pero útil en operaciones de PUT/POST).
    public UsuarioYaExisteException(Long id) {
        super("El Usuario con ID " + id + " ya existe en el sistema.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

public class UsuarioNoEncontradoException extends RuntimeException {

    // ESTE ES EL CONSTRUCTOR NECESARIO:
    public UsuarioNoEncontradoException(String message) {
        super(message); // Llama al constructor de RuntimeException para establecer el mensaje.
    }

    // Puedes añadir otros, pero este es el mínimo requerido para el orElseThrow
    public UsuarioNoEncontradoException(String message, Throwable cause) {
        super(message, cause);
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

// Recomendación: Es mejor que la excepción sea 'final' si solo extiende la funcionalidad base.
public final class TelefonoNoEncontradoException extends RuntimeException {

    // 1. ELIMINADO/COMENTADO: public TelefonoNoEncontradoException(String mensaje) {
    //    Este constructor es el que entra en conflicto con el Constructor 4 (String telefono).
    // }

    // 2. Constructor que envuelve otra excepción (útil para el debug).
    public TelefonoNoEncontradoException(String mensaje, Throwable causa) {
        // Mantenemos este constructor ya que su firma es única (String, Throwable).
        super(mensaje, causa);
    }

    // 3. Constructor especializado para buscar por ID (el más común en repositorios).
    public TelefonoNoEncontradoException(Long id) {
        // Mantenemos este constructor ya que su firma es única (Long).
        super("El Teléfono con ID " + id + " no fue encontrado en el sistema.");
    }

    // 4. Constructor especializado para buscar por número de teléfono (String).
    // Este constructor ahora maneja todos los casos donde se pase un String simple.
    public TelefonoNoEncontradoException(String telefono) {
        super("El número de teléfono '" + telefono + "' no está registrado o no fue encontrado.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

public final class RolNoEncontradoException extends RuntimeException {

    // 1. Constructor simple con mensaje (mantenido por flexibilidad)
    public RolNoEncontradoException(String mensaje) {
        super(mensaje);
    }

    // 2. Constructor que envuelve otra excepción (para debug y traza de errores)
    public RolNoEncontradoException(String mensaje, Throwable causa) {
        super(mensaje, causa);
    }

    // 3. Constructor especializado para buscar por ID (Clave Primaria: Long)
    public RolNoEncontradoException(Long id) {
        super("El Rol con ID " + id + " no fue encontrado en el sistema.");
    }

    // 4. Constructor especializado para buscar por Nombre (Clave de Negocio: String, Ej: "ROLE_MEDICO")
    public RolNoEncontradoException(String nombre, boolean porNombre) {
        // Usamos un flag booleano dummy para diferenciar del constructor simple (String mensaje).
        super("El Rol con nombre '" + nombre + "' no fue encontrado.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

public final class PacienteYaExisteException extends RuntimeException {

    // 1. ELIMINADO/COMENTADO: public PacienteYaExisteException(String mensaje) {
    //    Este constructor es el que entra en conflicto con el Constructor 3 (identificacion).
    // }

    // 2. Constructor que envuelve otra excepción (para debug)
    public PacienteYaExisteException(String mensaje, Throwable causa) {
        // Mantenemos este constructor ya que su firma es única (String, Throwable)
        super(mensaje, causa);
    }

    // 3. Constructor especializado para indicar que la identificación (ID) ya existe.
    // Este constructor ahora maneja todos los casos donde se pase un String simple.
    // El ID de Paciente es un String (la cédula).
    public PacienteYaExisteException(String identificacion) {
        super("El Paciente con identificación '" + identificacion + "' ya se encuentra registrado.");
    }

    // 4. Constructor especializado para indicar que el correo electrónico ya existe.
    // Mantenemos este constructor ya que su firma es única (String, boolean)
    public PacienteYaExisteException(String correo, boolean porCorreo) {
        super("El correo electrónico '" + correo + "' ya está asociado a otro paciente.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

public final class PacienteNoEncontradoException extends RuntimeException {

    // 1. ELIMINADO/COMENTADO: public PacienteNoEncontradoException(String mensaje) {
    //    Este constructor es el que entra en conflicto con el Constructor 3 (identificacion).
    // }

    // 2. Constructor que envuelve otra excepción (para debug y traza de errores)
    public PacienteNoEncontradoException(String mensaje, Throwable causa) {
        // Mantenemos este constructor ya que su firma es única (String, Throwable)
        super(mensaje, causa);
    }

    // 3. Constructor especializado para buscar por ID (Identificación/Cédula)
    // Este constructor ahora manejará todos los casos donde se pase un String simple.
    // El ID de Paciente es un String.
    public PacienteNoEncontradoException(String identificacion) {
        super("El Paciente con identificación " + identificacion + " no fue encontrado en el sistema.");
    }

    // 4. Constructor especializado para buscar por Correo Electrónico (clave de negocio)
    // Mantenemos este constructor ya que su firma es única (String, boolean)
    public PacienteNoEncontradoException(String correo, boolean esCorreo) {
        super("El Paciente con correo " + correo + " no fue encontrado en el sistema.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

public final class MedicoYaExisteException extends RuntimeException {

    // ELIMINAR O COMENTAR: public MedicoYaExisteException(String mensaje) { ... }
    // Ya que entra en conflicto con el constructor que recibe 'identificacion'.

    // 1. Constructor especializado para indicar que el ID/Identificación ya existe (String)
    // Asume que si se pasa un solo String, es el ID.
    public MedicoYaExisteException(String id) {
        super("El Médico con ID/Identificación " + id + " ya existe en el sistema.");
    }

    // 2. Constructor que envuelve otra excepción (para debug y traza de errores)
    public MedicoYaExisteException(String mensaje, Throwable causa) {
        super(mensaje, causa);
    }

    // 3. Constructor especializado para Correo Electrónico (Requiere un segundo parámetro para diferenciar la firma)
    // Ejemplo de cómo diferenciar: usando un flag booleano
    public MedicoYaExisteException(String correo, boolean esCorreo) {
        // Usamos un flag booleano dummy para diferenciar del constructor de solo String
        super("El Médico con correo " + correo + " ya existe en el sistema.");
    }

    // 4. Constructor especializado para indicar que el ID es un Long (si tu ID fuera numérico)
    // Puedes dejarlo si existe la posibilidad de buscar por ID numérico en tu Repositorio
    public MedicoYaExisteException(Long id, boolean porId) {
        // Usamos un flag booleano dummy para diferenciar del constructor de solo Long
        super("El Médico con ID " + id + " ya existe en el sistema.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

public final class MedicoNoEncontradoException extends RuntimeException {

    // 1. ELIMINADO/COMENTADO: public MedicoNoEncontradoException(String mensaje) {
    //    Este constructor es el que entra en conflicto con el Constructor 4 (username).
    // }

    // 2. Constructor que envuelve otra excepción (para debug y traza de errores)
    public MedicoNoEncontradoException(String mensaje, Throwable causa) {
        super(mensaje, causa);
    }

    // 3. Constructor especializado para buscar por ID (Clave Primaria: Long)
    public MedicoNoEncontradoException(Long id) {
        super("El Médico con ID " + id + " no fue encontrado en el sistema.");
    }

    // 4. Constructor especializado para buscar por Username (Clave de Autenticación)
    // Este constructor ahora manejará todos los casos donde se pase un String simple.
    public MedicoNoEncontradoException(String username) {
        super("El Médico asociado al username '" + username + "' no fue encontrado.");
    }

    // 5. Constructor especializado para buscar por Correo Electrónico (Clave de Negocio)
    // Usa el booleano 'esCorreo' para diferenciar su firma del Constructor 4.
    public MedicoNoEncontradoException(String correo, boolean esCorreo) {
        super("El Médico con correo '" + correo + "' no fue encontrado en el sistema.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

public final class MedicamentoYaExisteException extends RuntimeException {

    // 1. Constructor simple con mensaje (mantenido por flexibilidad)
    public MedicamentoYaExisteException(String mensaje) {
        super(mensaje);
    }

    // 2. Constructor que envuelve otra excepción (para debug)
    public MedicamentoYaExisteException(String mensaje, Throwable causa) {
        super(mensaje, causa);
    }

    // 3. Constructor especializado para indicar que el nombre del medicamento ya existe.
    // Usamos un flag booleano dummy para diferenciar del constructor simple (String mensaje).
    public MedicamentoYaExisteException(String nombre, boolean porNombre) {
        super("El medicamento con nombre '" + nombre + "' ya está registrado en el inventario.");
    }

    // 4. Constructor especializado para indicar que el ID de medicamento ya existe (menos común, pero útil).
    public MedicamentoYaExisteException(Long id) {
        super("El Medicamento con ID " + id + " ya existe en el sistema.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

public final class MedicamentoNoEncontradoException extends RuntimeException {

    // 1. Constructor simple con mensaje (mantenido por flexibilidad)
    public MedicamentoNoEncontradoException(String mensaje) {
        super(mensaje);
    }

    // 2. Constructor que envuelve otra excepción (para debug y traza de errores)
    public MedicamentoNoEncontradoException(String mensaje, Throwable causa) {
        super(mensaje, causa);
    }

    // 3. Constructor especializado para buscar por ID (Clave Primaria: Long)
    public MedicamentoNoEncontradoException(Long id) {
        super("El Medicamento con ID " + id + " no fue encontrado en el inventario.");
    }

    // 4. Constructor especializado para buscar por Nombre (Clave de Negocio: String)
    // Usamos un flag booleano dummy para diferenciar del constructor simple (String mensaje).
    public MedicamentoNoEncontradoException(String nombre, boolean esNombre) {
        // Asumimos que el String pasado es el nombre del medicamento
        super("El Medicamento con nombre '" + nombre + "' no fue encontrado.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.userdetails.UsernameNotFoundException; // Importación necesaria
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    // --- MANEJADOR UNIFICADO PARA EXCEPCIONES DE 'RECURSO NO ENCONTRADO' (404 NOT_FOUND) ---
    @ExceptionHandler({
            MedicoNoEncontradoException.class,
            EpsNoEncontradaException.class,
            EspecialidadNoEncontradaException.class,
            TelefonoNoEncontradoException.class,
            PacienteNoEncontradoException.class,
            CitaNoEncontradaException.class,
            MedicamentoNoEncontradoException.class,
            FormulaNoEncontradaException.class,
            DetalleFormulaNoEncontradaException.class,
            UsuarioNoEncontradoException.class,
            RolNoEncontradoException.class
    })
    public ResponseEntity<Map<String, Object>> handleNotFoundExceptions(RuntimeException ex) {
        return buildErrorResponse(
                ex,
                HttpStatus.NOT_FOUND,
                "Not Found"
        );
    }

    // --- MANEJADOR UNIFICADO PARA EXCEPCIONES DE 'CONFLICTO DE NEGOCIO' (409 CONFLICT) ---
    @ExceptionHandler({
            UsuarioYaExisteException.class,
            PacienteYaExisteException.class,
            MedicoYaExisteException.class,
            MedicamentoYaExisteException.class,
            CitaConflictoHorarioException.class
    })
    public ResponseEntity<Map<String, Object>> handleConflictExceptions(RuntimeException ex) {
        return buildErrorResponse(
                ex,
                HttpStatus.CONFLICT,
                "Conflict"
        );
    }

    // --- MANEJADOR ESPECÍFICO DE AUTENTICACIÓN (401 UNAUTHORIZED) ---
    /**
     * Captura las excepciones lanzadas por el AuthenticationManager para retornar 401.
     * Esto corrige el error donde el login fallido retornaba 500.
     */
    @ExceptionHandler({
            BadCredentialsException.class,
            UsernameNotFoundException.class // Cuando el UserDetailsService no encuentra el usuario
    })
    public ResponseEntity<Map<String, Object>> handleAuthenticationExceptions(RuntimeException ex) {
        // Usamos el mensaje de la excepción de seguridad
        String message = (ex.getMessage() != null && !ex.getMessage().isEmpty())
                ? ex.getMessage()
                : "Credenciales inválidas o usuario no encontrado.";

        // Retornamos 401 Unauthorized
        return buildErrorResponse(
                new RuntimeException(message),
                HttpStatus.UNAUTHORIZED,
                "Unauthorized"
        );
    }

    // --- MANEJADOR PARA SOLICITUDES INVÁLIDAS (400 BAD_REQUEST) ---
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<Map<String, Object>> handleIllegalArgument(IllegalArgumentException ex) {
        return buildErrorResponse(
                ex,
                HttpStatus.BAD_REQUEST,
                "Bad Request"
        );
    }

    // --- MANEJADOR GENERAL DE ERRORES INTERNOS (500 INTERNAL_SERVER_ERROR) ---
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, Object>> handleGeneralException(Exception ex) {
        return buildErrorResponse(
                ex,
                HttpStatus.INTERNAL_SERVER_ERROR,
                "Internal Server Error"
        );
    }

    // --- MÉTODO DE CONSTRUCCIÓN DE RESPUESTA CENTRALIZADO ---
    /**
     * Construye y formatea el cuerpo de la respuesta de error HTTP.
     */
    private ResponseEntity<Map<String, Object>> buildErrorResponse(
            Exception ex,
            HttpStatus status,
            String errorType) {

        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", status.value());
        body.put("error", errorType);
        body.put("message", ex.getMessage());

        return new ResponseEntity<>(body, status);
    }
} package medisystem.avanzada.uq.citas_service.exceptions;

public final class FormulaNoEncontradaException extends RuntimeException {

    // 1. Constructor simple con mensaje (mantenido por flexibilidad)
    public FormulaNoEncontradaException(String mensaje) {
        super(mensaje);
    }

    // 2. Constructor que envuelve otra excepción (para debug y traza de errores)
    public FormulaNoEncontradaException(String mensaje, Throwable causa) {
        super(mensaje, causa);
    }

    // 3. Constructor especializado para buscar por ID (Clave Primaria: Long)
    // El ID de Formula fue estandarizado a Long.
    public FormulaNoEncontradaException(Long id) {
        super("La Fórmula con ID " + id + " no fue encontrada en el sistema.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

// Se recomienda que las excepciones de negocio sean 'final'.
public final class EspecialidadYaExisteException extends RuntimeException {

    // 1. Constructor simple con mensaje (útil para errores genéricos)
    public EspecialidadYaExisteException(String message) {
        super(message);
    }

    // 2. Constructor especializado para indicar que el nombre ya existe (el más usado en POST/PUT).
    // Usamos el flag booleano 'porNombre' para diferenciar la firma del constructor simple (String message).
    public EspecialidadYaExisteException(String nombre, boolean porNombre) {
        super("La Especialidad '" + nombre + "' ya está registrada en el sistema.");
    }

    // 3. Constructor especializado para indicar que el ID ya existe (útil en operaciones de PUT/POST).
    public EspecialidadYaExisteException(Long id) {
        super("La Especialidad con ID " + id + " ya existe en el sistema.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

public final class EspecialidadNoEncontradaException extends RuntimeException {

    // 1. Constructor simple con mensaje (mantenido por flexibilidad)
    public EspecialidadNoEncontradaException(String mensaje) {
        super(mensaje);
    }

    // 2. Constructor que envuelve otra excepción (para debug y traza de errores)
    public EspecialidadNoEncontradaException(String mensaje, Throwable causa) {
        super(mensaje, causa);
    }

    // 3. Constructor especializado para buscar por ID (Clave Primaria: Long)
    // El ID de Especialidad fue estandarizado a Long.
    public EspecialidadNoEncontradaException(Long id) {
        super("La Especialidad con ID " + id + " no fue encontrada en el sistema.");
    }

    // 4. Constructor especializado para buscar por Nombre (Clave de Negocio: String)
    public EspecialidadNoEncontradaException(String nombre, boolean esNombre) {
        // Usamos un flag booleano dummy para diferenciar del constructor simple (String mensaje).
        super("La Especialidad '" + nombre + "' no fue encontrada en el sistema.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

// Se recomienda que las excepciones de negocio sean 'final'.
public final class EpsYaExisteException extends RuntimeException {

    // 1. Constructor simple con mensaje (útil para errores genéricos)
    public EpsYaExisteException(String message) {
        super(message);
    }

    // 2. Constructor especializado para indicar que el nombre ya existe (el más usado en POST/PUT).
    // Usamos el flag booleano 'porNombre' para diferenciar la firma del constructor simple (String message).
    public EpsYaExisteException(String nombre, boolean porNombre) {
        super("La EPS '" + nombre + "' ya está registrada en el sistema.");
    }

    // 3. Constructor especializado para indicar que el ID ya existe (útil en operaciones de PUT/POST).
    // Usamos Long, ya que estandarizamos el ID de Eps a Long.
    public EpsYaExisteException(Long id) {
        super("La EPS con ID " + id + " ya existe en el sistema.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

public final class EpsNoEncontradaException extends RuntimeException {

    // 1. Constructor simple con mensaje (mantenido por flexibilidad)
    public EpsNoEncontradaException(String mensaje) {
        super(mensaje);
    }

    // 2. Constructor que envuelve otra excepción (para debug y traza de errores)
    public EpsNoEncontradaException(String mensaje, Throwable causa) {
        super(mensaje, causa);
    }

    // 3. Constructor especializado para buscar por ID (Clave Primaria: Long)
    // El ID de Eps fue estandarizado a Long.
    public EpsNoEncontradaException(Long id) {
        super("La EPS con ID " + id + " no fue encontrada en el sistema.");
    }

    // 4. Constructor especializado para buscar por Nombre (Clave de Negocio: String)
    public EpsNoEncontradaException(String nombre, boolean esNombre) {
        // Usamos un flag booleano dummy para diferenciar del constructor simple (String mensaje).
        super("La EPS '" + nombre + "' no fue encontrada en el sistema.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

public final class DetalleFormulaNoEncontradaException extends RuntimeException {

    // 1. Constructor simple con mensaje (mantenido por flexibilidad)
    public DetalleFormulaNoEncontradaException(String mensaje) {
        super(mensaje);
    }

    // 2. Constructor que envuelve otra excepción (para debug y traza de errores)
    public DetalleFormulaNoEncontradaException(String mensaje, Throwable causa) {
        super(mensaje, causa);
    }

    // 3. Constructor especializado para buscar por ID (Clave Primaria: Long)
    // El ID de DetalleFormula fue estandarizado a Long.
    public DetalleFormulaNoEncontradaException(Long id) {
        super("El Detalle de Fórmula con ID " + id + " no fue encontrado en el sistema.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

// Se recomienda 'final'
public final class CitaNoEncontradaException extends RuntimeException {

    // 1. Constructor simple con mensaje (mantenido por flexibilidad)
    public CitaNoEncontradaException(String mensaje) {
        super(mensaje);
    }

    // 2. Constructor que envuelve otra excepción (para debug)
    public CitaNoEncontradaException(String mensaje, Throwable causa) {
        super(mensaje, causa);
    }

    // 3. Constructor especializado para buscar por ID (el más común).
    // Usamos Long, ya que estandarizamos el ID de Cita a Long.
    public CitaNoEncontradaException(Long id) {
        super("La Cita con ID " + id + " no fue encontrada en el sistema.");
    }
}package medisystem.avanzada.uq.citas_service.exceptions;

public final class CitaConflictoHorarioException extends RuntimeException {

    // 1. Constructor principal con mensaje detallado del conflicto (mantenido por necesidad).
    // La capa de Servicio debe construir un mensaje específico (Ej: "El médico X está ocupado de 10:00 a 11:00").
    public CitaConflictoHorarioException(String mensaje) {
        super(mensaje);
    }

    // 2. Constructor que envuelve otra excepción (para debug).
    public CitaConflictoHorarioException(String mensaje, Throwable causa) {
        super(mensaje, causa);
    }
}package medisystem.avanzada.uq.citas_service.entities;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Set;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.EqualsAndHashCode;

@Entity
@Table(name = "usuarios")
@Getter
@Setter
@NoArgsConstructor
@EqualsAndHashCode(of = "username")
public class Usuario {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id_usuario")
    private Long id;

    @Column(name = "username", unique = true, nullable = false)
    private String username;

    @Column(name = "password", nullable = false)
    private String password;

    @ManyToMany(fetch = FetchType.LAZY) // CAMBIADO: EAGER -> LAZY
    @JoinTable(
            name = "usuarios_roles",
            joinColumns = @JoinColumn(name = "id_usuario"),
            inverseJoinColumns = @JoinColumn(name = "id_rol")
    )
    private Set<Rol> roles = new HashSet<>();

    public Usuario(String username, String password) {
        this.username = username;
        this.password = password;
    }

}package medisystem.avanzada.uq.citas_service.repositories;

import medisystem.avanzada.uq.citas_service.entities.Usuario;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.Optional;

public interface UsuarioRepository extends JpaRepository<Usuario, Long> {

    /**
     * Consulta optimizada para la capa de Servicio/Seguridad.
     * Utiliza JOIN FETCH para cargar la entidad Usuario y su colección de Roles
     * en una sola consulta, evitando el problema N+1 y manteniendo la eficiencia
     * del FetchType.LAZY en la entidad.
     */
    @Query("SELECT u FROM Usuario u JOIN FETCH u.roles r WHERE u.username = :username")
    Optional<Usuario> findByUsernameWithRoles(@Param("username") String username);

    // Consulta simple para otros casos que no requieran roles inmediatamente.
    Optional<Usuario> findByUsername(String username);

    // Método eficiente para verificar si un username ya existe.
    boolean existsByUsername(String username);
}package medisystem.avanzada.uq.citas_service.repositories;

import medisystem.avanzada.uq.citas_service.entities.Telefono;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface TelefonoRepository extends JpaRepository<Telefono, Long> { // <-- CORREGIDO: Integer -> Long

    // Método esencial para buscar un número de teléfono por su valor String.
    Optional<Telefono> findByTelefono(String telefono);
}package medisystem.avanzada.uq.citas_service.repositories;

import medisystem.avanzada.uq.citas_service.entities.Rol;
import medisystem.avanzada.uq.citas_service.entities.RolNombre;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository; // Importación necesaria
import java.util.Optional;

@Repository // Mantenemos esta anotación por consistencia de estilo.
public interface RolRepository extends JpaRepository<Rol, Long> {

    // Método para encontrar un rol por su nombre (clave natural), usando Optional.
    Optional<Rol> findByNombre(RolNombre nombre);

    // Método para verificar la existencia (opcional, pero útil para validaciones).
    boolean existsByNombre(RolNombre nombre);
}package medisystem.avanzada.uq.citas_service.repositories;

import medisystem.avanzada.uq.citas_service.entities.Paciente;
import medisystem.avanzada.uq.citas_service.entities.PacienteTelefono;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface PacienteTelefonoRepository extends JpaRepository<PacienteTelefono, Long> {

    /**
     * Devuelve todos los registros de la tabla de unión
     * que corresponden a un Paciente específico.
     * Esta es la consulta principal que usa el servicio.
     */
    List<PacienteTelefono> findAllByPaciente(Paciente paciente);

    /**
     * Elimina todos los registros de teléfonos para un paciente dado.
     * Útil al actualizar o eliminar un paciente.
     */
    void deleteAllByPaciente(Paciente paciente);
}package medisystem.avanzada.uq.citas_service.repositories;

import medisystem.avanzada.uq.citas_service.entities.Paciente;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface PacienteRepository extends JpaRepository<Paciente, String> {

    // Encuentra un Paciente por su correo electrónico (clave única)
    Optional<Paciente> findByCorreo(String correo);

    // Verifica si ya existe un paciente con un correo específico (más eficiente que findByCorreo)
    boolean existsByCorreo(String correo);

    // Encuentra un Paciente a través del username de su Usuario asociado
    Optional<Paciente> findByUsuarioUsername(String username);
}package medisystem.avanzada.uq.citas_service.repositories;

import medisystem.avanzada.uq.citas_service.entities.Medico;
import medisystem.avanzada.uq.citas_service.entities.Especialidad;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface MedicoRepository extends JpaRepository<Medico, Long> {

    // Consulta por el username del usuario asociado (original)
    Optional<Medico> findByUsuarioUsername(String username);

    // Búsqueda por la clave natural 'correo'
    Optional<Medico> findByCorreo(String correo);

    // Validación rápida de existencia por correo
    boolean existsByCorreo(String correo);

    // Método para encontrar médicos por su especialidad, útil para citas.
    List<Medico> findByEspecialidad(Especialidad especialidad);

}package medisystem.avanzada.uq.citas_service.repositories;

import medisystem.avanzada.uq.citas_service.entities.Medicamento;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface MedicamentoRepository extends JpaRepository<Medicamento, Long> {

    // CORREGIDO: findByNombre -> findByNombreMedicamento
    // Método esencial para buscar medicamentos al crear una fórmula.
    Optional<Medicamento> findByNombreMedicamento(String nombre);

    // CORREGIDO: existsByNombre -> existsByNombreMedicamento
    // Método para validar que no haya nombres de medicamentos duplicados.
    boolean existsByNombreMedicamento(String nombre);
}package medisystem.avanzada.uq.citas_service.repositories;

import medisystem.avanzada.uq.citas_service.entities.Formula;
import medisystem.avanzada.uq.citas_service.entities.Cita;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface FormulaRepository extends JpaRepository<Formula, Long> {

    // Método para buscar una fórmula asociada a una cita específica.
    Optional<Formula> findByCita(Cita cita);

    // Método para verificar la existencia (útil para lógica de negocio).
    boolean existsByCita(Cita cita);
}package medisystem.avanzada.uq.citas_service.repositories;

import medisystem.avanzada.uq.citas_service.entities.Especialidad;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface EspecialidadRepository extends JpaRepository<Especialidad, Long> {

    // Método esencial para buscar una especialidad por su nombre (clave natural y única).
    Optional<Especialidad> findByNombreEspecialidad(String nombreEspecialidad);

    // Método para validar que no existan nombres duplicados, optimizado para la existencia.
    boolean existsByNombreEspecialidad(String nombreEspecialidad);
}package medisystem.avanzada.uq.citas_service.repositories;

import medisystem.avanzada.uq.citas_service.entities.DetalleFormula;
import medisystem.avanzada.uq.citas_service.entities.Formula;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface DetalleFormulaRepository extends JpaRepository<DetalleFormula, Long> {

    /**
     * Encuentra todos los detalles (medicamentos) asociados a una fórmula específica.
     * Esta es la consulta principal para esta tabla.
     */
    List<DetalleFormula> findByFormula(Formula formula);
}package medisystem.avanzada.uq.citas_service.repositories;

import medisystem.avanzada.uq.citas_service.entities.Eps;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface EpsRepository extends JpaRepository<Eps, Long> {

    // Método esencial para buscar una EPS por su nombre (clave natural y única).
    Optional<Eps> findByNombreEps(String nombreEps);

    // Método para validar que no existan nombres duplicados.
    boolean existsByNombreEps(String nombreEps);
}package medisystem.avanzada.uq.citas_service.repositories;

import medisystem.avanzada.uq.citas_service.entities.Cita;
import medisystem.avanzada.uq.citas_service.entities.Medico;
import medisystem.avanzada.uq.citas_service.entities.Paciente;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;

@Repository
public interface CitaRepository extends JpaRepository<Cita, Long> { // <-- CAMBIADO: Integer -> Long

    // Consulta para el límite de citas de un médico por día (original)
    int countByMedicoAndFecha(Medico medico, LocalDate fecha);

    // Búsqueda de disponibilidad precisa (original)
    boolean existsByMedicoAndFechaAndHoraInicio(Medico medico, LocalDate fecha, LocalTime horaInicio);

    // Funcionalidad clave: Obtener citas por paciente.
    List<Cita> findByPaciente(Paciente paciente);

    // Funcionalidad clave: Obtener citas por médico.
    List<Cita> findByMedico(Medico medico);
}package medisystem.avanzada.uq.citas_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration;

@SpringBootApplication(
		exclude = {
				org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class,
				org.springframework.boot.actuate.autoconfigure.security.servlet.ManagementWebSecurityAutoConfiguration.class
		}
)
public class CitasServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(CitasServiceApplication.class, args);
	}

}
package medisystem.avanzada.uq.citas_service.services;

import medisystem.avanzada.uq.citas_service.dtos.usuario.UsuarioResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Usuario;
import medisystem.avanzada.uq.citas_service.entities.RolNombre;

import java.util.Optional;

public interface UserService {

    /**
     * Crea un nuevo usuario en el sistema con una contraseña encriptada y un rol específico.
     * Este es el método central de registro, llamado por MedicoService y PacienteService.
     * * @param username El nombre de usuario (único).
     * @param password La contraseña en texto plano.
     * @param rolNombre El rol a asignar (MEDICO, PACIENTE, ADMINISTRADOR).
     * @return La entidad Usuario recién creada.
     */
    Usuario crearNuevoUsuario(String username, String password, RolNombre rolNombre);

    /**
     * Busca una entidad Usuario por su nombre de usuario.
     * @param username El nombre de usuario.
     * @return Un Optional que contiene la entidad si se encuentra.
     */
    Optional<Usuario> findByUsername(String username);

    /**
     * Devuelve el perfil del usuario para el cliente (omitiendo la contraseña).
     * @param username El nombre de usuario.
     * @return El DTO de respuesta con roles y nombre de usuario.
     */
    UsuarioResponseDTO getPerfilUsuario(String username);
}package medisystem.avanzada.uq.citas_service.security.jwt;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.UnsupportedJwtException;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException; // Necesaria para el manejo de excepciones
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.List;

@Component
public class JwtTokenProvider {

    private final String secretString;
    private final SecretKey secretKey;
    private final long expirationTime = 86400000; // 24 horas en milisegundos

    public JwtTokenProvider(@Value("${jwt.secret}") String secretString) {
        // La clave debe tener al menos 256 bits (32 caracteres)
        this.secretString = secretString;
        this.secretKey = Keys.hmacShaKeyFor(secretString.getBytes());
    }

    public SecretKey getSecretKey() {
        return secretKey;
    }

    // ==========================================================
    // Generar token
    // ==========================================================
    public String generarToken(String username, List<String> roles) {
        Date ahora = new Date();
        Date expiracion = new Date(ahora.getTime() + expirationTime);

        return Jwts.builder()
                .subject(username)
                .claim("roles", roles)
                .issuedAt(ahora)
                .expiration(expiracion)
                .signWith(secretKey, SignatureAlgorithm.HS256)
                .compact();
    }

    // ==========================================================
    // Validación del token (MÉTODO FALTANTE CORREGIDO)
    // ==========================================================
    /**
     * Valida la firma y la fecha de expiración del token.
     * @param token El JWT a validar.
     * @return true si el token es válido, false en caso contrario.
     */
    public boolean validarToken(String token) {
        try {
            Jwts.parser()
                    .verifyWith(secretKey)
                    .build()
                    .parseSignedClaims(token);
            return true;
        } catch (SignatureException | MalformedJwtException | ExpiredJwtException |
                 UnsupportedJwtException | IllegalArgumentException e) {
            // Manejo de errores de validación de firma o expiración.
            return false;
        }
    }

    // ==========================================================
    // Obtener Claims
    // ==========================================================
    public String obtenerUsernameDelToken(String token) {
        return Jwts.parser()
                .verifyWith(secretKey)
                .build()
                .parseSignedClaims(token)
                .getPayload()
                .getSubject();
    }
}package medisystem.avanzada.uq.citas_service.security.jwt;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;

    public JwtAuthenticationFilter(JwtTokenProvider jwtTokenProvider) {
        this.jwtTokenProvider = jwtTokenProvider;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        String header = request.getHeader("Authorization");

        if (header != null && header.startsWith("Bearer ")) {
            String token = header.substring(7);

            if (jwtTokenProvider.validarToken(token)) {

                // 1. Extraer claims
                Claims claims = Jwts.parser()
                        .verifyWith(jwtTokenProvider.getSecretKey())
                        .build()
                        .parseSignedClaims(token)
                        .getPayload();

                String username = claims.getSubject();
                // NOTA: Los roles en el payload del JWT son el nombre limpio (ADMINISTRADOR)
                List<String> roles = claims.get("roles", List.class);

                // 2. Convertir los roles en autoridades de Spring
                // ¡CORRECCIÓN CLAVE! Ya no añadimos "ROLE_", ya que la BD no lo tiene
                // y el SecurityConfig fue ajustado con GrantedAuthorityDefaults("").
                List<SimpleGrantedAuthority> authorities = roles != null
                        ? roles.stream()
                        .map(r -> new SimpleGrantedAuthority(r)) // <-- Se quitó "ROLE_" +
                        .collect(Collectors.toList())
                        : Collections.emptyList();

                // 3. Crear el objeto de autenticación
                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(
                                new User(username, "", authorities), // Principio de seguridad
                                null,
                                authorities);

                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                // 4. Establecer la autenticación en el contexto de seguridad
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }

        filterChain.doFilter(request, response);
    }
}
package medisystem.avanzada.uq.citas_service.services;

import medisystem.avanzada.uq.citas_service.dtos.telefono.TelefonoRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.telefono.TelefonoResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Telefono; // Necesario para el uso interno

import java.util.List;

public interface TelefonoService {

    // --------------------------------------------------------------------
    // MÉTODOS DE NEGOCIO (Uso interno por PacienteService)
    // --------------------------------------------------------------------

    /**
     * Busca la entidad Telefono por su número o la crea si no existe.
     * Devuelve la entidad Telefono para que el PacienteService pueda manejar la relación.
     * @param numero El número de teléfono.
     * @return La entidad Telefono existente o recién creada.
     */
    Telefono findOrCreateByNumero(String numero);

    // --------------------------------------------------------------------
    // MÉTODOS CRUD ESTANDARIZADOS (Uso por el Controller)
    // --------------------------------------------------------------------

    /**
     * Devuelve todos los teléfonos como DTOs.
     */
    List<TelefonoResponseDTO> getAllTelefonos();

    /**
     * Busca un teléfono por su ID.
     */
    TelefonoResponseDTO getTelefonoById(Long idTelefono); // ID estandarizado a Long

    /**
     * Crea un nuevo teléfono.
     */
    TelefonoResponseDTO postTelefono(TelefonoRequestDTO dto);

    /**
     * Reemplaza completamente los datos de un teléfono.
     */
    TelefonoResponseDTO putTelefono(Long idTelefono, TelefonoRequestDTO dto);

    /**
     * Elimina un teléfono por ID.
     */
    void deleteTelefono(Long idTelefono); // ID estandarizado a Long

    /**
     * Actualiza parcialmente los datos de un teléfono.
     */
    TelefonoResponseDTO patchTelefono(Long idTelefono, TelefonoRequestDTO dto);
}package medisystem.avanzada.uq.citas_service.services;

import medisystem.avanzada.uq.citas_service.dtos.paciente.PacienteRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.paciente.PacienteResponseDTO;
import java.util.List;

public interface PacienteService {

    // --- MÉTODOS DE LECTURA (GET) ---
    List<PacienteResponseDTO> getAllPacientes();
    PacienteResponseDTO getPacienteById(String idPaciente);

    // --- MÉTODO DE CREACIÓN (POST, con nombre de negocio) ---
    // Usamos el nombre registrarPaciente para la lógica compleja de creación/usuario.
    PacienteResponseDTO registrarPaciente(PacienteRequestDTO dto);

    // --- MÉTODOS DE ACTUALIZACIÓN (PUT/PATCH) ---
    // Renombramos y tipamos para usar RequestDTOs y devolver ResponseDTOs
    PacienteResponseDTO putPaciente(String idPaciente, PacienteRequestDTO dto);
    PacienteResponseDTO patchPaciente(String idPaciente, PacienteRequestDTO dto);

    // --- MÉTODO DE ELIMINACIÓN (DELETE) ---
    void deletePaciente(String idPaciente);
}package medisystem.avanzada.uq.citas_service.services;

import medisystem.avanzada.uq.citas_service.dtos.medico.MedicoRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.medico.MedicoResponseDTO;
// Eliminamos la importación de Especialidad
// import medisystem.avanzada.uq.citas_service.entities.Especialidad;

import java.util.List;

public interface MedicoService {

    // --- MÉTODOS DE REGISTRO Y LECTURA (GET/POST) ---

    /**
     * Registra un nuevo médico en el sistema, creando su usuario asociado.
     * @param dto Los datos de registro, incluyendo usuario y especialidad.
     * @return El DTO de respuesta del médico creado.
     */
    MedicoResponseDTO registrarMedico(MedicoRequestDTO dto);

    /**
     * Devuelve una lista de todos los médicos, transformados a DTOs de respuesta.
     */
    List<MedicoResponseDTO> getAllMedicos();

    /**
     * Busca un médico por su ID (PK) y lo devuelve como DTO.
     */
    MedicoResponseDTO getMedicoById(Long idMedico);

    // --- MÉTODOS DE ACTUALIZACIÓN (PUT/PATCH) ---

    /**
     * Actualiza completamente los datos de un médico existente.
     */
    MedicoResponseDTO updateMedico(Long idMedico, MedicoRequestDTO dto);

    /**
     * Actualiza parcialmente los datos de un médico (requiere lógica de nulidad en la implementación).
     */
    MedicoResponseDTO patchMedico(Long idMedico, MedicoRequestDTO dto);

    // --- MÉTODOS DE ELIMINACIÓN (DELETE) ---

    /**
     * Elimina lógicamente (o físicamente) un médico del sistema.
     */
    void deleteMedico(Long idMedico);

    // --- MÉTODOS DE CONSULTA ESPECÍFICA ---

    /**
     * Busca y devuelve una lista de médicos que pertenecen a una especialidad dada.
     * @param idEspecialidad El ID de la especialidad a buscar.
     */
    List<MedicoResponseDTO> getMedicosByEspecialidadId(Long idEspecialidad); // Ajustado para usar Long
}package medisystem.avanzada.uq.citas_service.services;

import medisystem.avanzada.uq.citas_service.dtos.medicamento.MedicamentoRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.medicamento.MedicamentoResponseDTO;
import java.util.List;

public interface MedicamentoService {

    List<MedicamentoResponseDTO> getMedicamentos();

    // CAMBIADO: Integer -> Long
    MedicamentoResponseDTO getMedicamentoById(Long idMedicamento);

    MedicamentoResponseDTO postMedicamento(MedicamentoRequestDTO medicamentoDTO);

    // CAMBIADO: Integer -> Long
    MedicamentoResponseDTO putMedicamento(Long idMedicamento, MedicamentoRequestDTO medicamentoDTO);

    // CAMBIADO: Integer -> Long
    void deleteMedicamento(Long idMedicamento);

    // CAMBIADO: Integer -> Long
    MedicamentoResponseDTO patchMedicamento(Long idMedicamento, MedicamentoRequestDTO medicamentoDTO);
}package medisystem.avanzada.uq.citas_service.services;

import medisystem.avanzada.uq.citas_service.dtos.formula.FormulaRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.formula.FormulaResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Formula;
import java.util.List;

public interface FormulaService {

    // --- Métodos originales que trabajan con la entidad (Ajustados a DTOs y Long) ---
    // Usaremos DTOs para actualizar, no entidades.
    FormulaResponseDTO update(Long id, FormulaRequestDTO dto); // CAMBIADO: int -> Long, Formula -> DTO
    void delete(Long id); // CAMBIADO: int -> Long

    // --- Nuevos métodos con DTOs ---
    List<FormulaResponseDTO> findAll();
    FormulaResponseDTO findById(Long id); // CAMBIADO: int -> Long
    FormulaResponseDTO save(FormulaRequestDTO dto);
}package medisystem.avanzada.uq.citas_service.services;

import medisystem.avanzada.uq.citas_service.dtos.especialidad.EspecialidadRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.especialidad.EspecialidadResponseDTO;

import java.util.List;

public interface EspecialidadService {

    /**
     * Devuelve todas las especialidades como DTOs.
     */
    List<EspecialidadResponseDTO> getAllEspecialidades();

    /**
     * Busca una especialidad por su ID.
     */
    EspecialidadResponseDTO getEspecialidadById(Long idEspecialidad);

    /**
     * Crea una nueva especialidad.
     */
    EspecialidadResponseDTO postEspecialidad(EspecialidadRequestDTO dto);

    /**
     * Actualiza completamente los datos de una especialidad.
     */
    EspecialidadResponseDTO putEspecialidad(Long idEspecialidad, EspecialidadRequestDTO dto);

    /**
     * Actualiza parcialmente los datos de una especialidad.
     */
    EspecialidadResponseDTO patchEspecialidad(Long idEspecialidad, EspecialidadRequestDTO dto);

    /**
     * Elimina una especialidad por ID.
     */
    void deleteEspecialidad(Long idEspecialidad);
}package medisystem.avanzada.uq.citas_service.services;

import medisystem.avanzada.uq.citas_service.dtos.eps.EpsRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.eps.EpsResponseDTO;

import java.util.List;

public interface EpsService {

    /**
     * Devuelve todas las EPS como DTOs.
     */
    List<EpsResponseDTO> getAllEps();

    /**
     * Busca una EPS por su ID.
     */
    EpsResponseDTO getEpsById(Long idEps); // Usamos Long para el ID

    /**
     * Crea una nueva EPS.
     */
    EpsResponseDTO postEps(EpsRequestDTO dto);

    /**
     * Actualiza completamente los datos de una EPS.
     */
    EpsResponseDTO putEps(Long idEps, EpsRequestDTO dto);

    /**
     * Actualiza parcialmente los datos de una EPS.
     */
    EpsResponseDTO patchEps(Long idEps, EpsRequestDTO dto);

    /**
     * Elimina una EPS por ID.
     */
    void deleteEps(Long idEps);
}package medisystem.avanzada.uq.citas_service.services;

import medisystem.avanzada.uq.citas_service.dtos.detalleFormula.DetalleFormulaRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.detalleFormula.DetalleFormulaResponseDTO;

import java.util.List;

public interface DetalleFormulaService {

    List<DetalleFormulaResponseDTO> getDetalleFormulas();

    // CAMBIADO: Integer -> Long
    DetalleFormulaResponseDTO getDetalleFormulaById(Long idDetalleFormula);

    DetalleFormulaResponseDTO postDetalleFormula(DetalleFormulaRequestDTO detalleFormulaDTO);

    // CAMBIADO: Integer -> Long
    DetalleFormulaResponseDTO putDetalleFormula(Long idDetalleFormula, DetalleFormulaRequestDTO detalleFormulaDTO);

    // CAMBIADO: Integer -> Long
    void deleteDetalleFormula(Long idDetalleFormula);

    // CAMBIADO: Integer -> Long
    DetalleFormulaResponseDTO patchDetalleFormula(Long idDetalleFormula, DetalleFormulaRequestDTO detalleFormulaDTO);
}package medisystem.avanzada.uq.citas_service.services;

import medisystem.avanzada.uq.citas_service.dtos.cita.CitaRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.cita.CitaResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Paciente;
import medisystem.avanzada.uq.citas_service.entities.Medico;

import java.util.List;

public interface CitaService {

    // ==========================================================
    // CREACIÓN / AGENDAMIENTO (POST)
    // ==========================================================
    /**
     * Agenda una nueva cita, aplicando toda la lógica de validación.
     */
    CitaResponseDTO agendarCita(CitaRequestDTO dto);

    // ==========================================================
    // LECTURA (GET)
    // ==========================================================
    /**
     * Devuelve todas las citas como DTOs.
     */
    List<CitaResponseDTO> getAllCitas();

    /**
     * Busca una cita por su ID.
     */
    CitaResponseDTO getCitaById(Long idCita);

    /**
     * Devuelve el historial de citas de un paciente.
     */
    List<CitaResponseDTO> findByPaciente(Paciente paciente);

    /**
     * Devuelve la agenda de citas de un médico.
     */
    List<CitaResponseDTO> findByMedico(Medico medico);

    // ==========================================================
    // ACTUALIZACIÓN Y ELIMINACIÓN (PUT/PATCH/DELETE)
    // ==========================================================
    /**
     * Reemplaza completamente los datos de una cita (PUT).
     */
    CitaResponseDTO updateCita(Long idCita, CitaRequestDTO dto);

    /**
     * Actualiza parcialmente los datos de una cita (PATCH).
     */
    CitaResponseDTO patchCita(Long idCita, CitaRequestDTO dto);

    /**
     * Cancela o elimina una cita.
     */
    void deleteCita(Long idCita);
}package medisystem.avanzada.uq.citas_service.services.impl;

import medisystem.avanzada.uq.citas_service.dtos.usuario.UsuarioResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Rol;
import medisystem.avanzada.uq.citas_service.entities.RolNombre;
import medisystem.avanzada.uq.citas_service.entities.Usuario;
import medisystem.avanzada.uq.citas_service.mappers.UsuarioMapper;
import medisystem.avanzada.uq.citas_service.repositories.RolRepository;
import medisystem.avanzada.uq.citas_service.repositories.UsuarioRepository;
import medisystem.avanzada.uq.citas_service.services.UserService;
import medisystem.avanzada.uq.citas_service.exceptions.UsuarioYaExisteException; // Nueva excepción (409)
import medisystem.avanzada.uq.citas_service.exceptions.UsuarioNoEncontradoException; // Nueva excepción (404)
import medisystem.avanzada.uq.citas_service.exceptions.RolNoEncontradoException; // Nueva excepción (500)

import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;
import java.util.Set;

@Service
@Transactional
public class UserServiceImpl implements UserService {

    private final UsuarioRepository usuarioRepository;
    private final RolRepository rolRepository;
    private final PasswordEncoder passwordEncoder;
    private final UsuarioMapper usuarioMapper;

    // Inyección de dependencias (Constructor) - PRÁCTICA RECOMENDADA
    public UserServiceImpl(UsuarioRepository usuarioRepository, RolRepository rolRepository,
                           PasswordEncoder passwordEncoder, UsuarioMapper usuarioMapper) {
        this.usuarioRepository = usuarioRepository;
        this.rolRepository = rolRepository;
        this.passwordEncoder = passwordEncoder;
        this.usuarioMapper = usuarioMapper;
    }

    @Override
    public Usuario crearNuevoUsuario(String username, String password, RolNombre rolNombre) {
        // Validación: Lanza la excepción específica 409
        if (usuarioRepository.existsByUsername(username)) {
            throw new UsuarioYaExisteException("El nombre de usuario '" + username + "' ya está en uso.");
        }

        Usuario usuario = new Usuario();
        usuario.setUsername(username);

        // 1. Encriptación: Codifica la contraseña
        usuario.setPassword(passwordEncoder.encode(password));

        // 2. Asignación de Rol: Usa la excepción específica 500 para errores de configuración
        Rol rol = rolRepository.findByNombre(rolNombre)
                .orElseThrow(() -> new RolNoEncontradoException("Error de configuración: Rol '" + rolNombre.name() + "' no encontrado en la BD."));

        usuario.setRoles(Set.of(rol));

        // 3. Guardar y retornar
        return usuarioRepository.save(usuario);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<Usuario> findByUsername(String username) {
        // El método solo retorna el Optional, el manejo de errores lo hace quien lo consume.
        return usuarioRepository.findByUsername(username);
    }

    @Override
    @Transactional(readOnly = true)
    public UsuarioResponseDTO getPerfilUsuario(String username) {

        // Uso de la excepción 404 específica y mensaje claro.
        Usuario usuario = usuarioRepository.findByUsername(username)

                // CORRECTO: La expresión lambda simple funciona perfectamente.
                .orElseThrow(() -> new UsuarioNoEncontradoException("Usuario con username '" + username + "' no encontrado."));

        // Uso del mapper
        return usuarioMapper.toResponseDTO(usuario);
    }
}package medisystem.avanzada.uq.citas_service.services.impl;

import medisystem.avanzada.uq.citas_service.entities.Usuario;
import medisystem.avanzada.uq.citas_service.entities.Rol;
import medisystem.avanzada.uq.citas_service.repositories.UsuarioRepository;
import medisystem.avanzada.uq.citas_service.exceptions.UsuarioNoEncontradoException;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UsuarioRepository usuarioRepository;

    public UserDetailsServiceImpl(UsuarioRepository usuarioRepository) {
        this.usuarioRepository = usuarioRepository;
    }

    /**
     * Carga el objeto Usuario y sus roles (GrantedAuthorities) desde la base de datos
     * y lo envuelve en un objeto UserDetails de Spring Security.
     * @param username El nombre de usuario que intenta iniciar sesión.
     * @return UserDetails que contiene el username, password y roles/permisos.
     */
    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 1. Buscar Usuario y Roles
        Usuario usuario = usuarioRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("Usuario no encontrado con username: " + username));

        // 2. Convertir los Roles a GrantedAuthorities
        // ¡La autoridad ahora coincide con el nombre del ENUM (ej: "ADMINISTRADOR")!
        Collection<? extends GrantedAuthority> authorities = mapRolesToAuthorities(usuario.getRoles());

        // 3. Devolver un objeto User de Spring Security
        return new User(
                usuario.getUsername(),
                usuario.getPassword(), // Contraseña encriptada
                authorities
        );
    }

    /**
     * Convierte el Set<Rol> de la entidad JPA a la colección de GrantedAuthority de Spring Security.
     * IMPORTANTE: Se ha eliminado el prefijo "ROLE_" ya que la base de datos no lo usa
     * y el SecurityConfig fue ajustado con GrantedAuthorityDefaults("").
     */
    private Collection<? extends GrantedAuthority> mapRolesToAuthorities(Set<Rol> roles) {
        // Mapea cada Rol a un SimpleGrantedAuthority (ej: "ADMINISTRADOR", "MEDICO")
        return roles.stream()
                .map(rol -> new SimpleGrantedAuthority(rol.getNombre().name())) // 🌟 CORRECCIÓN CLAVE: Quitar "ROLE_" +
                .collect(Collectors.toList());
    }
}
package medisystem.avanzada.uq.citas_service.services.impl;

import medisystem.avanzada.uq.citas_service.dtos.telefono.TelefonoRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.telefono.TelefonoResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Telefono;
import medisystem.avanzada.uq.citas_service.exceptions.TelefonoNoEncontradoException;
import medisystem.avanzada.uq.citas_service.mappers.TelefonoMapper; // NECESARIO para DTOs
import medisystem.avanzada.uq.citas_service.repositories.TelefonoRepository;
import medisystem.avanzada.uq.citas_service.services.TelefonoService;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service("dbTelefonoService")
@Transactional
public class TelefonoServiceImpl implements TelefonoService {

    private final TelefonoRepository telefonoRepository;
    private final TelefonoMapper telefonoMapper;

    // Inyección por Constructor
    public TelefonoServiceImpl(TelefonoRepository telefonoRepository, TelefonoMapper telefonoMapper) {
        this.telefonoRepository = telefonoRepository;
        this.telefonoMapper = telefonoMapper;
    }

    // --------------------------------------------------------------------
    // MÉTODOS DE NEGOCIO (Uso interno por PacienteService)
    // --------------------------------------------------------------------

    @Override
    @Transactional(readOnly = true)
    public Telefono findOrCreateByNumero(String numero) {
        // Usa el método findByTelefono que añadiste al Repositorio
        return telefonoRepository.findByTelefono(numero)
                .orElseGet(() -> {
                    // Si no existe, crea y guarda el nuevo teléfono
                    Telefono nuevoTelefono = new Telefono();
                    nuevoTelefono.setTelefono(numero);
                    return telefonoRepository.save(nuevoTelefono);
                });
    }

    // --------------------------------------------------------------------
    // MÉTODOS CRUD ESTANDARIZADOS (Uso por el Controller)
    // --------------------------------------------------------------------

    @Override
    @Transactional(readOnly = true)
    public List<TelefonoResponseDTO> getAllTelefonos() {
        // Retorna DTOs usando el stream y el mapper
        return telefonoRepository.findAll().stream()
                .map(telefonoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public TelefonoResponseDTO getTelefonoById(Long idTelefono) { // ID es LONG
        Telefono telefono = telefonoRepository.findById(idTelefono)
                .orElseThrow(() -> new TelefonoNoEncontradoException(idTelefono)); // Usa constructor (Long)

        return telefonoMapper.toResponseDTO(telefono);
    }

    @Override
    public TelefonoResponseDTO postTelefono(TelefonoRequestDTO dto) { // Acepta DTO
        // 1. Convertir DTO a Entidad
        Telefono telefono = telefonoMapper.toEntity(dto);

        // 2. Guardar
        Telefono guardado = telefonoRepository.save(telefono);

        // 3. Convertir Entidad a Response DTO
        return telefonoMapper.toResponseDTO(guardado);
    }

    @Override
    public TelefonoResponseDTO putTelefono(Long idTelefono, TelefonoRequestDTO dto) { // ID es LONG y acepta DTO
        // Buscar o lanzar 404
        Telefono existente = telefonoRepository.findById(idTelefono)
                .orElseThrow(() -> new TelefonoNoEncontradoException(idTelefono));

        // Actualizar: MapStruct o manualmente (si no usas MapStruct para updates)
        if (dto.getTelefono() != null) {
            existente.setTelefono(dto.getTelefono());
        }

        return telefonoMapper.toResponseDTO(telefonoRepository.save(existente));
    }

    @Override
    public void deleteTelefono(Long idTelefono) { // ID es LONG
        // Usamos existsById para validar y lanzar 404 si no existe
        if (!telefonoRepository.existsById(idTelefono)) {
            throw new TelefonoNoEncontradoException(idTelefono);
        }
        telefonoRepository.deleteById(idTelefono);
    }

    @Override
    public TelefonoResponseDTO patchTelefono(Long idTelefono, TelefonoRequestDTO dto) { // ID es LONG y acepta DTO
        // Buscar o lanzar 404
        Telefono existente = telefonoRepository.findById(idTelefono)
                .orElseThrow(() -> new TelefonoNoEncontradoException(idTelefono));

        // Actualización parcial
        if (dto.getTelefono() != null) {
            existente.setTelefono(dto.getTelefono());
        }

        return telefonoMapper.toResponseDTO(telefonoRepository.save(existente));
    }
}package medisystem.avanzada.uq.citas_service.services.impl;

import medisystem.avanzada.uq.citas_service.dtos.paciente.PacienteRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.paciente.PacienteResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.*;
import medisystem.avanzada.uq.citas_service.entities.RolNombre;
import medisystem.avanzada.uq.citas_service.exceptions.EpsNoEncontradaException;
import medisystem.avanzada.uq.citas_service.exceptions.PacienteNoEncontradoException;
import medisystem.avanzada.uq.citas_service.exceptions.PacienteYaExisteException;
import medisystem.avanzada.uq.citas_service.mappers.PacienteMapper;
import medisystem.avanzada.uq.citas_service.repositories.*;
import medisystem.avanzada.uq.citas_service.services.PacienteService;
import medisystem.avanzada.uq.citas_service.services.UserService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

@Service
@Transactional
public class PacienteServiceImpl implements PacienteService {

    private final PacienteRepository pacienteRepository;
    private final EpsRepository epsRepository;
    private final TelefonoRepository telefonoRepository;
    private final PacienteTelefonoRepository pacienteTelefonoRepository;
    private final UserService userService;
    private final PacienteMapper pacienteMapper;

    // Constructor limpio con todas las dependencias
    public PacienteServiceImpl(PacienteRepository pacienteRepository,
                               EpsRepository epsRepository,
                               TelefonoRepository telefonoRepository,
                               PacienteTelefonoRepository pacienteTelefonoRepository,
                               UserService userService,
                               PacienteMapper pacienteMapper) {
        this.pacienteRepository = pacienteRepository;
        this.epsRepository = epsRepository;
        this.telefonoRepository = telefonoRepository;
        this.pacienteTelefonoRepository = pacienteTelefonoRepository;
        this.userService = userService;
        this.pacienteMapper = pacienteMapper;
    }

    // ========================================================
    // LECTURA (GET)
    // ========================================================

    @Override
    @Transactional(readOnly = true)
    public List<PacienteResponseDTO> getAllPacientes() {
        return pacienteRepository.findAll().stream()
                .map(this::mapPacienteToResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public PacienteResponseDTO getPacienteById(String idPaciente) {
        Paciente paciente = pacienteRepository.findById(idPaciente)
                .orElseThrow(() -> new PacienteNoEncontradoException(idPaciente));
        return mapPacienteToResponseDTO(paciente);
    }

    // ========================================================
    // CREACIÓN (POST) - IMPLEMENTA registrarPaciente
    // ========================================================

    @Override
    public PacienteResponseDTO registrarPaciente(PacienteRequestDTO dto) {

        // Validación: El paciente (por cédula/ID) no debe existir
        if (pacienteRepository.existsById(dto.getIdPaciente())) {
            throw new PacienteYaExisteException(dto.getIdPaciente());
        }

        // 1. Crear/Validar Usuario (Delegado al UserService, incluye validación de username)
        Usuario usuario = userService.crearNuevoUsuario(
                dto.getUsername(),
                dto.getPassword(),
                RolNombre.PACIENTE
        );

        // 2. Buscar EPS
        Eps eps = epsRepository.findById(dto.getIdEps())
                // CORRECCIÓN: Pasar solo el Long (ID)
                .orElseThrow(() -> new EpsNoEncontradaException(dto.getIdEps()));

        // 3. Crear Entidad Paciente
        Paciente paciente = pacienteMapper.toEntity(dto, eps, usuario);
        paciente.setIdPaciente(dto.getIdPaciente());
        Paciente savedPaciente = pacienteRepository.save(paciente);

        // 4. Manejar y Guardar Teléfonos (Lógica compleja)
        Set<String> numerosGuardados = saveTelefonos(savedPaciente, dto.getTelefonos());

        // 5. Retornar DTO de salida
        return pacienteMapper.toResponseDTO(savedPaciente, numerosGuardados);
    }

    // ========================================================
    // ACTUALIZACIÓN TOTAL (PUT)
    // ========================================================

    @Override
    public PacienteResponseDTO putPaciente(String idPaciente, PacienteRequestDTO dto) {
        Paciente existente = pacienteRepository.findById(idPaciente)
                .orElseThrow(() -> new PacienteNoEncontradoException(idPaciente));

        // El ID del paciente no debe cambiar
        if (!existente.getIdPaciente().equals(dto.getIdPaciente())) {
            throw new IllegalArgumentException("No se permite cambiar la identificación del paciente.");
        }

        // 1. Actualizar campos simples
        existente.setNombrePaciente(dto.getNombrePaciente());
        existente.setCiudad(dto.getCiudad());
        existente.setCorreo(dto.getCorreo());

        // 2. Actualizar EPS
        Eps nuevaEps = epsRepository.findById(dto.getIdEps())
                // CORRECCIÓN: Pasar solo el Long (ID)
                .orElseThrow(() -> new EpsNoEncontradaException(dto.getIdEps()));
        existente.setEps(nuevaEps);

        // 3. ACTUALIZACIÓN DE TELÉFONOS (Borrar y recrear)
        Set<String> numerosGuardados = updateTelefonos(existente, dto.getTelefonos());

        Paciente updatedPaciente = pacienteRepository.save(existente);

        // 4. Retornar DTO
        return pacienteMapper.toResponseDTO(updatedPaciente, numerosGuardados);
    }

    // ========================================================
    // ACTUALIZACIÓN PARCIAL (PATCH)
    // ========================================================

    @Override
    public PacienteResponseDTO patchPaciente(String idPaciente, PacienteRequestDTO dto) {
        Paciente existente = pacienteRepository.findById(idPaciente)
                .orElseThrow(() -> new PacienteNoEncontradoException(idPaciente));

        boolean cambiosEnTelefono = false;

        // 1. Actualización condicional de campos simples
        if (dto.getNombrePaciente() != null) {
            existente.setNombrePaciente(dto.getNombrePaciente());
        }
        if (dto.getCiudad() != null) {
            existente.setCiudad(dto.getCiudad());
        }
        if (dto.getCorreo() != null) {
            existente.setCorreo(dto.getCorreo());
        }

        // 2. Actualizar EPS si el ID se proporciona
        if (dto.getIdEps() != null) {
            Eps nuevaEps = epsRepository.findById(dto.getIdEps())
                    // CORRECCIÓN: Pasar solo el Long (ID)
                    .orElseThrow(() -> new EpsNoEncontradaException(dto.getIdEps()));
            existente.setEps(nuevaEps);
        }

        // 3. ACTUALIZACIÓN DE TELÉFONOS (Si se proveen, se BORRAN los antiguos y se crean los nuevos)
        if (dto.getTelefonos() != null) {
            updateTelefonos(existente, dto.getTelefonos());
            cambiosEnTelefono = true;
        }

        Paciente updatedPaciente = pacienteRepository.save(existente);

        // 4. Retornar DTO
        Set<String> telefonos;
        if (cambiosEnTelefono) {
            // Si hubo cambio, se usa la lista recién guardada del DTO
            telefonos = dto.getTelefonos();
        } else {
            // Si no hubo cambio, se extrae la lista que ya tenía la entidad
            telefonos = updatedPaciente.getTelefonos().stream()
                    .map(pt -> pt.getTelefono().getTelefono())
                    .collect(Collectors.toSet());
        }

        return pacienteMapper.toResponseDTO(updatedPaciente, telefonos);
    }

    // ========================================================
    // ELIMINACIÓN (DELETE)
    // ========================================================

    @Override
    public void deletePaciente(String idPaciente) {
        Paciente paciente = pacienteRepository.findById(idPaciente)
                .orElseThrow(() -> new PacienteNoEncontradoException(idPaciente));

        pacienteRepository.delete(paciente);
    }

    // ========================================================
    // MÉTODOS PRIVADOS DE AYUDA (Lógica de Teléfonos)
    // ========================================================

    /** Convierte la entidad Paciente a DTO, resolviendo la lista de teléfonos. */
    private PacienteResponseDTO mapPacienteToResponseDTO(Paciente paciente) {
        Set<String> telefonos = paciente.getTelefonos().stream()
                .map(pt -> pt.getTelefono().getTelefono())
                .collect(Collectors.toSet());
        return pacienteMapper.toResponseDTO(paciente, telefonos);
    }

    /** Lógica para guardar las relaciones de teléfono (usada en POST). */
    private Set<String> saveTelefonos(Paciente paciente, Set<String> numeros) {
        if (numeros == null) return Set.of();
        Set<String> numerosGuardados = new HashSet<>();

        for (String numero : numeros) {
            // Busca o crea la entidad Telefono
            Telefono telefonoEntity = telefonoRepository.findByTelefono(numero)
                    .orElseGet(() -> {
                        Telefono nuevoTelefono = new Telefono();
                        nuevoTelefono.setTelefono(numero);
                        return telefonoRepository.save(nuevoTelefono);
                    });

            // Crea la entidad de unión PacienteTelefono
            PacienteTelefono pt = new PacienteTelefono();
            pt.setPaciente(paciente);
            pt.setTelefono(telefonoEntity);
            pacienteTelefonoRepository.save(pt);

            numerosGuardados.add(numero);
        }
        return numerosGuardados;
    }

    /** Lógica para actualizar las relaciones de teléfono (usada en PUT/PATCH). */
    private Set<String> updateTelefonos(Paciente paciente, Set<String> nuevosNumeros) {
        // 1. Borrar vínculos antiguos
        pacienteTelefonoRepository.deleteAllByPaciente(paciente);

        // 2. Guardar los nuevos (usa la lógica de saveTelefonos)
        return saveTelefonos(paciente, nuevosNumeros);
    }
}package medisystem.avanzada.uq.citas_service.services.impl;

import medisystem.avanzada.uq.citas_service.dtos.medico.MedicoRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.medico.MedicoResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Medico;
import medisystem.avanzada.uq.citas_service.entities.Especialidad;
import medisystem.avanzada.uq.citas_service.entities.Usuario;
import medisystem.avanzada.uq.citas_service.entities.RolNombre;
import medisystem.avanzada.uq.citas_service.exceptions.EspecialidadNoEncontradaException;
import medisystem.avanzada.uq.citas_service.exceptions.MedicoNoEncontradoException;
import medisystem.avanzada.uq.citas_service.exceptions.MedicoYaExisteException;
import medisystem.avanzada.uq.citas_service.mappers.MedicoMapper;
import medisystem.avanzada.uq.citas_service.repositories.MedicoRepository;
import medisystem.avanzada.uq.citas_service.repositories.EspecialidadRepository;
import medisystem.avanzada.uq.citas_service.services.MedicoService;
import medisystem.avanzada.uq.citas_service.services.UserService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Transactional
public class MedicoServiceImpl implements MedicoService {

    private final MedicoRepository medicoRepository;
    private final EspecialidadRepository especialidadRepository;
    private final UserService userService; // Inyección para la lógica de Usuario
    private final MedicoMapper medicoMapper; // Inyección del Mapper

    public MedicoServiceImpl(MedicoRepository medicoRepository,
                             EspecialidadRepository especialidadRepository,
                             UserService userService,
                             MedicoMapper medicoMapper) {
        this.medicoRepository = medicoRepository;
        this.especialidadRepository = especialidadRepository;
        this.userService = userService;
        this.medicoMapper = medicoMapper;
    }

    // ========================================================
    // CREACIÓN Y REGISTRO (POST)
    // ========================================================

    @Override
    public MedicoResponseDTO registrarMedico(MedicoRequestDTO dto) {
        // Validación 1: El correo no debe existir
        if (medicoRepository.existsByCorreo(dto.getCorreo())) {
            throw new MedicoYaExisteException(dto.getCorreo(), true);
        }

        // Validación 2: El usuario no debe existir (Delegado a UserService)

        // 1. Crear Usuario (Delegado al UserService para encriptación y rol)
        Usuario usuario = userService.crearNuevoUsuario(
                dto.getUsername(),
                dto.getPassword(),
                RolNombre.MEDICO
        );

        // 2. Buscar Especialidad
        Especialidad especialidad = especialidadRepository.findById(dto.getIdEspecialidad())
                .orElseThrow(() -> new EspecialidadNoEncontradaException(dto.getIdEspecialidad()));

        // 3. Crear Entidad Medico (Usando el Mapper)
        Medico medico = medicoMapper.toEntity(dto, usuario, especialidad);
        // NOTA: El ID del médico es autogenerado (Long), no se toma del DTO.

        Medico savedMedico = medicoRepository.save(medico);

        // 4. Retornar DTO de salida
        return medicoMapper.toResponseDTO(savedMedico);
    }

    // ========================================================
    // LECTURA (GET)
    // ========================================================

    @Override
    @Transactional(readOnly = true)
    public List<MedicoResponseDTO> getAllMedicos() {
        return medicoRepository.findAll().stream()
                .map(medicoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public MedicoResponseDTO getMedicoById(Long idMedico) {
        Medico medico = medicoRepository.findById(idMedico)
                .orElseThrow(() -> new MedicoNoEncontradoException(idMedico));

        return medicoMapper.toResponseDTO(medico);
    }

    @Override
    @Transactional(readOnly = true)
    public List<MedicoResponseDTO> getMedicosByEspecialidadId(Long idEspecialidad) {
        Especialidad especialidad = especialidadRepository.findById(idEspecialidad)
                .orElseThrow(() -> new EspecialidadNoEncontradaException(idEspecialidad));

        // Usa el método optimizado del repositorio (findByEspecialidad)
        return medicoRepository.findByEspecialidad(especialidad).stream()
                .map(medicoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    // ========================================================
    // ACTUALIZACIÓN (PUT/PATCH)
    // ========================================================

    @Override
    public MedicoResponseDTO updateMedico(Long idMedico, MedicoRequestDTO dto) {
        Medico existente = medicoRepository.findById(idMedico)
                .orElseThrow(() -> new MedicoNoEncontradoException(idMedico));

        // 1. Validar que el correo no se duplique con otro médico
        if (medicoRepository.existsByCorreo(dto.getCorreo()) &&
                !existente.getCorreo().equalsIgnoreCase(dto.getCorreo())) {
            throw new MedicoYaExisteException(dto.getCorreo(), true);
        }

        // 2. Actualizar Especialidad (Requiere búsqueda)
        Especialidad nuevaEspecialidad = especialidadRepository.findById(dto.getIdEspecialidad())
                .orElseThrow(() -> new EspecialidadNoEncontradaException(dto.getIdEspecialidad()));

        // 3. Actualizar campos
        existente.setNombreMedico(dto.getNombreMedico());
        existente.setTelefono(dto.getTelefono());
        existente.setCorreo(dto.getCorreo());
        existente.setEspecialidad(nuevaEspecialidad);

        // 4. NOTA: La actualización del Usuario (username/password) debe ser un método separado en UserService.

        Medico updatedMedico = medicoRepository.save(existente);

        // 5. Retornar DTO
        return medicoMapper.toResponseDTO(updatedMedico);
    }

    @Override
    public MedicoResponseDTO patchMedico(Long idMedico, MedicoRequestDTO dto) {
        Medico existente = medicoRepository.findById(idMedico)
                .orElseThrow(() -> new MedicoNoEncontradoException(idMedico));

        // Aquí se requiere lógica compleja de mapeo nulo que MapStruct no hace fácilmente con un DTO.
        // Se implementa manualmente la lógica de PATCH (solo actualiza si el campo no es nulo).

        if (dto.getNombreMedico() != null) {
            existente.setNombreMedico(dto.getNombreMedico());
        }
        if (dto.getTelefono() != null) {
            existente.setTelefono(dto.getTelefono());
        }
        if (dto.getCorreo() != null) {
            // Validar correo en PATCH
            if (medicoRepository.existsByCorreo(dto.getCorreo()) &&
                    !existente.getCorreo().equalsIgnoreCase(dto.getCorreo())) {
                throw new MedicoYaExisteException(dto.getCorreo(), true);
            }
            existente.setCorreo(dto.getCorreo());
        }
        if (dto.getIdEspecialidad() != null) {
            Especialidad nuevaEspecialidad = especialidadRepository.findById(dto.getIdEspecialidad())
                    .orElseThrow(() -> new EspecialidadNoEncontradaException(dto.getIdEspecialidad()));
            existente.setEspecialidad(nuevaEspecialidad);
        }

        // NOTA: Los campos de usuario (username, password) NO se manejan aquí.

        Medico updatedMedico = medicoRepository.save(existente);
        return medicoMapper.toResponseDTO(updatedMedico);
    }

    // ========================================================
    // ELIMINACIÓN (DELETE)
    // ========================================================

    @Override
    public void deleteMedico(Long idMedico) {
        Medico medico = medicoRepository.findById(idMedico)
                .orElseThrow(() -> new MedicoNoEncontradoException(idMedico));

        medicoRepository.delete(medico);
        // El borrado del Usuario asociado debería ocurrir por la configuración de Cascade en la entidad Medico.
    }
}package medisystem.avanzada.uq.citas_service.services.impl;

import medisystem.avanzada.uq.citas_service.dtos.medicamento.MedicamentoRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.medicamento.MedicamentoResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Medicamento;
import medisystem.avanzada.uq.citas_service.exceptions.MedicamentoNoEncontradoException;
import medisystem.avanzada.uq.citas_service.exceptions.MedicamentoYaExisteException; // Importación necesaria
import medisystem.avanzada.uq.citas_service.mappers.MedicamentoMapper;
import medisystem.avanzada.uq.citas_service.repositories.MedicamentoRepository;
import medisystem.avanzada.uq.citas_service.services.MedicamentoService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service("dbMedicamentoService")
@Transactional
public class MedicamentoServiceImpl implements MedicamentoService {

    private final MedicamentoRepository medicamentoRepository;
    private final MedicamentoMapper medicamentoMapper;

    public MedicamentoServiceImpl(MedicamentoRepository medicamentoRepository,
                                  MedicamentoMapper medicamentoMapper) {
        this.medicamentoRepository = medicamentoRepository;
        this.medicamentoMapper = medicamentoMapper;
    }

    // ========================================================
    // LECTURA (GET)
    // ========================================================

    @Override
    @Transactional(readOnly = true)
    public List<MedicamentoResponseDTO> getMedicamentos() {
        return medicamentoRepository.findAll()
                .stream()
                .map(medicamentoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public MedicamentoResponseDTO getMedicamentoById(Long idMedicamento) {
        Medicamento medicamento = medicamentoRepository.findById(idMedicamento)
                .orElseThrow(() -> new MedicamentoNoEncontradoException(idMedicamento));
        return medicamentoMapper.toResponseDTO(medicamento);
    }

    // ========================================================
    // CREACIÓN (POST)
    // ========================================================

    @Override
    public MedicamentoResponseDTO postMedicamento(MedicamentoRequestDTO medicamentoDTO) {
        // Validación de Negocio: No debe existir otro con el mismo nombre
        // CORRECCIÓN 1: existsByNombre -> existsByNombreMedicamento
        if (medicamentoRepository.existsByNombreMedicamento(medicamentoDTO.getNombreMedicamento())) {
            throw new MedicamentoYaExisteException(medicamentoDTO.getNombreMedicamento(), true);
        }

        Medicamento entity = medicamentoMapper.toEntity(medicamentoDTO);
        Medicamento saved = medicamentoRepository.save(entity);
        return medicamentoMapper.toResponseDTO(saved);
    }

    // ========================================================
    // ACTUALIZACIÓN TOTAL (PUT)
    // ========================================================

    @Override
    public MedicamentoResponseDTO putMedicamento(Long idMedicamento, MedicamentoRequestDTO medicamentoDTO) {
        Medicamento existente = medicamentoRepository.findById(idMedicamento)
                .orElseThrow(() -> new MedicamentoNoEncontradoException(idMedicamento));

        // Validación de Negocio: Si el nombre cambia, debe ser único
        if (!existente.getNombreMedicamento().equalsIgnoreCase(medicamentoDTO.getNombreMedicamento())) {
            // CORRECCIÓN 2: existsByNombre -> existsByNombreMedicamento
            if (medicamentoRepository.existsByNombreMedicamento(medicamentoDTO.getNombreMedicamento())) {
                throw new MedicamentoYaExisteException(medicamentoDTO.getNombreMedicamento(), true);
            }
        }

        existente.setNombreMedicamento(medicamentoDTO.getNombreMedicamento());
        existente.setPrecio(medicamentoDTO.getPrecio());

        Medicamento actualizado = medicamentoRepository.save(existente);
        return medicamentoMapper.toResponseDTO(actualizado);
    }

    // ========================================================
    // ELIMINACIÓN (DELETE)
    // ========================================================

    @Override
    public void deleteMedicamento(Long idMedicamento) {
        // Verificamos existencia para lanzar 404
        if (!medicamentoRepository.existsById(idMedicamento)) {
            throw new MedicamentoNoEncontradoException(idMedicamento);
        }
        medicamentoRepository.deleteById(idMedicamento);
    }

    // ========================================================
    // ACTUALIZACIÓN PARCIAL (PATCH)
    // ========================================================

    @Override
    public MedicamentoResponseDTO patchMedicamento(Long idMedicamento, MedicamentoRequestDTO medicamentoDTO) {
        Medicamento existente = medicamentoRepository.findById(idMedicamento)
                .orElseThrow(() -> new MedicamentoNoEncontradoException(idMedicamento));

        if (medicamentoDTO.getNombreMedicamento() != null) {
            // Validación de Negocio: Si se proporciona un nombre, debe ser único
            if (!existente.getNombreMedicamento().equalsIgnoreCase(medicamentoDTO.getNombreMedicamento())) {
                // CORRECCIÓN 3: existsByNombre -> existsByNombreMedicamento
                if (medicamentoRepository.existsByNombreMedicamento(medicamentoDTO.getNombreMedicamento())) {
                    throw new MedicamentoYaExisteException(medicamentoDTO.getNombreMedicamento(), true);
                }
            }
            existente.setNombreMedicamento(medicamentoDTO.getNombreMedicamento());
        }
        if (medicamentoDTO.getPrecio() != null) {
            existente.setPrecio(medicamentoDTO.getPrecio());
        }

        Medicamento actualizado = medicamentoRepository.save(existente);
        return medicamentoMapper.toResponseDTO(actualizado);
    }
}package medisystem.avanzada.uq.citas_service.services.impl;

import medisystem.avanzada.uq.citas_service.dtos.formula.FormulaRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.formula.FormulaResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Cita;
import medisystem.avanzada.uq.citas_service.entities.Formula;
import medisystem.avanzada.uq.citas_service.entities.Medico;
import medisystem.avanzada.uq.citas_service.exceptions.CitaNoEncontradaException;
import medisystem.avanzada.uq.citas_service.exceptions.FormulaNoEncontradaException;
import medisystem.avanzada.uq.citas_service.exceptions.MedicoNoEncontradoException;
import medisystem.avanzada.uq.citas_service.mappers.FormulaMapper;
import medisystem.avanzada.uq.citas_service.repositories.CitaRepository;
import medisystem.avanzada.uq.citas_service.repositories.FormulaRepository;
import medisystem.avanzada.uq.citas_service.repositories.MedicoRepository;
import medisystem.avanzada.uq.citas_service.services.FormulaService;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Transactional
public class FormulaServiceImpl implements FormulaService {

    private final FormulaRepository formulaRepository;
    private final CitaRepository citaRepository;
    private final FormulaMapper formulaMapper;
    private final MedicoRepository medicoRepository;
    // Eliminada la inyección de CitaMapper y CitaResponseDTO

    public FormulaServiceImpl(FormulaRepository formulaRepository,
                              CitaRepository citaRepository,
                              FormulaMapper formulaMapper,
                              MedicoRepository medicoRepository) {
        this.formulaRepository = formulaRepository;
        this.citaRepository = citaRepository;
        this.formulaMapper = formulaMapper;
        this.medicoRepository = medicoRepository;
    }

    // ==========================================================
    // LECTURA (GET)
    // ==========================================================

    @Override
    @Transactional(readOnly = true)
    public List<FormulaResponseDTO> findAll() {
        return formulaRepository.findAll()
                .stream()
                // Uso del mapper simplificado
                .map(formulaMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    // CORREGIDO: int -> Long
    public FormulaResponseDTO findById(Long id) {
        Formula formula = formulaRepository.findById(id)
                // Uso de la excepción con Long
                .orElseThrow(() -> new FormulaNoEncontradaException(id));

        // Uso del mapper simplificado
        return formulaMapper.toResponseDTO(formula);
    }

    // ==========================================================
    // CREACIÓN (POST)
    // ==========================================================

    @Override
    public FormulaResponseDTO save(FormulaRequestDTO dto) {
        Cita cita = citaRepository.findById(dto.getIdCita())
                // Uso de la excepción con Long
                .orElseThrow(() -> new CitaNoEncontradaException(dto.getIdCita()));

        // Verificar si la cita ya tiene una fórmula
        if (cita.getFormula() != null) {
            throw new RuntimeException("La cita con ID " + dto.getIdCita() + " ya tiene una fórmula asociada.");
        }

        // El servicio de seguridad debe verificar que el médico autenticado sea el dueño de la cita

        Formula formula = formulaMapper.toEntity(dto, cita);
        Formula guardada = formulaRepository.save(formula);

        // Uso del mapper simplificado
        return formulaMapper.toResponseDTO(guardada);
    }

    // ==========================================================
    // ACTUALIZACIÓN (PUT)
    // ==========================================================

    @Override
    // CORREGIDO: int -> Long, Formula -> FormulaRequestDTO
    public FormulaResponseDTO update(Long id, FormulaRequestDTO dto) {
        Formula existente = formulaRepository.findById(id)
                .orElseThrow(() -> new FormulaNoEncontradaException(id));

        // Validación de Autoría
        verificarPropiedadMedico(existente);

        // Actualizar solo los campos que se pueden modificar (fecha y detalles)
        if (dto.getFecha() != null) {
            existente.setFecha(dto.getFecha());
        }
        // NOTA: La actualización de los detalles (medicamentos) se haría aquí.

        return formulaMapper.toResponseDTO(formulaRepository.save(existente));
    }

    // ==========================================================
    // ELIMINACIÓN (DELETE)
    // ==========================================================

    @Override
    // CORREGIDO: int -> Long
    public void delete(Long id) {
        Formula formula = formulaRepository.findById(id)
                .orElseThrow(() -> new FormulaNoEncontradaException(id));

        // Validación de Autoría
        verificarPropiedadMedico(formula);

        formulaRepository.delete(formula);
    }

    // ==========================================================
    // Método auxiliar: verifica que el médico autenticado sea dueño de la fórmula
    // ==========================================================
    private void verificarPropiedadMedico(Formula formula) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String username = auth.getName();

        // Se usa findByUsuarioUsername del MedicoRepository
        Medico medicoActual = medicoRepository.findByUsuarioUsername(username)
                .orElseThrow(() -> new MedicoNoEncontradoException(username));

        Medico medicoDeFormula = formula.getCita().getMedico();
        if (!medicoDeFormula.getIdMedico().equals(medicoActual.getIdMedico())) {
            throw new RuntimeException("No tienes permiso para modificar o eliminar la fórmula de otro médico.");
        }
    }
}package medisystem.avanzada.uq.citas_service.services.impl;

import medisystem.avanzada.uq.citas_service.dtos.especialidad.EspecialidadRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.especialidad.EspecialidadResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Especialidad;
import medisystem.avanzada.uq.citas_service.exceptions.EspecialidadNoEncontradaException;
import medisystem.avanzada.uq.citas_service.exceptions.EspecialidadYaExisteException; // Excepción necesaria
import medisystem.avanzada.uq.citas_service.mappers.EspecialidadMapper;
import medisystem.avanzada.uq.citas_service.repositories.EspecialidadRepository;
import medisystem.avanzada.uq.citas_service.services.EspecialidadService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service("dbEspecialidadService")
@Transactional
public class EspecialidadServiceImpl implements EspecialidadService {

    private final EspecialidadRepository especialidadRepository;
    private final EspecialidadMapper especialidadMapper;

    public EspecialidadServiceImpl(EspecialidadRepository especialidadRepository,
                                   EspecialidadMapper especialidadMapper) {
        this.especialidadRepository = especialidadRepository;
        this.especialidadMapper = especialidadMapper;
    }

    // ========================================================
    // LECTURA (GET) - Corregido para devolver DTOs
    // ========================================================

    @Override
    @Transactional(readOnly = true)
    public List<EspecialidadResponseDTO> getAllEspecialidades() {
        return especialidadRepository.findAll().stream()
                .map(especialidadMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public EspecialidadResponseDTO getEspecialidadById(Long idEspecialidad) {
        Especialidad especialidad = especialidadRepository.findById(idEspecialidad)
                .orElseThrow(() -> new EspecialidadNoEncontradaException(idEspecialidad));

        return especialidadMapper.toResponseDTO(especialidad);
    }

    // ========================================================
    // CREACIÓN (POST) - Corregido para usar DTOs y validación
    // ========================================================

    @Override
    public EspecialidadResponseDTO postEspecialidad(EspecialidadRequestDTO dto) {
        // Validación de Negocio: No debe existir otra con el mismo nombre
        if (especialidadRepository.existsByNombreEspecialidad(dto.getNombreEspecialidad())) {
            throw new EspecialidadYaExisteException(dto.getNombreEspecialidad(), true);
        }

        Especialidad entity = especialidadMapper.toEntity(dto);
        Especialidad saved = especialidadRepository.save(entity);
        return especialidadMapper.toResponseDTO(saved);
    }

    // ========================================================
    // ACTUALIZACIÓN TOTAL (PUT) - Corregido para usar DTOs
    // ========================================================

    @Override
    public EspecialidadResponseDTO putEspecialidad(Long idEspecialidad, EspecialidadRequestDTO dto) {
        Especialidad existente = especialidadRepository.findById(idEspecialidad)
                .orElseThrow(() -> new EspecialidadNoEncontradaException(idEspecialidad));

        // Validación de Negocio: Si el nombre cambia, debe ser único
        if (!existente.getNombreEspecialidad().equalsIgnoreCase(dto.getNombreEspecialidad())) {
            if (especialidadRepository.existsByNombreEspecialidad(dto.getNombreEspecialidad())) {
                throw new EspecialidadYaExisteException(dto.getNombreEspecialidad(), true);
            }
        }

        existente.setNombreEspecialidad(dto.getNombreEspecialidad());

        Especialidad actualizado = especialidadRepository.save(existente);
        return especialidadMapper.toResponseDTO(actualizado);
    }

    // ========================================================
    // ACTUALIZACIÓN PARCIAL (PATCH) - Corregido para usar DTOs
    // ========================================================

    @Override
    public EspecialidadResponseDTO patchEspecialidad(Long idEspecialidad, EspecialidadRequestDTO dto) {
        Especialidad existente = especialidadRepository.findById(idEspecialidad)
                .orElseThrow(() -> new EspecialidadNoEncontradaException(idEspecialidad));

        if (dto.getNombreEspecialidad() != null) {
            // Validación de Negocio: Si el nombre cambia, debe ser único
            if (!existente.getNombreEspecialidad().equalsIgnoreCase(dto.getNombreEspecialidad())) {
                if (especialidadRepository.existsByNombreEspecialidad(dto.getNombreEspecialidad())) {
                    throw new EspecialidadYaExisteException(dto.getNombreEspecialidad(), true);
                }
            }
            existente.setNombreEspecialidad(dto.getNombreEspecialidad());
        }

        Especialidad actualizado = especialidadRepository.save(existente);
        return especialidadMapper.toResponseDTO(actualizado);
    }

    // ========================================================
    // ELIMINACIÓN (DELETE)
    // ========================================================

    @Override
    public void deleteEspecialidad(Long idEspecialidad) {
        // Usamos existsById para validar antes de borrar
        if (!especialidadRepository.existsById(idEspecialidad)) {
            throw new EspecialidadNoEncontradaException(idEspecialidad);
        }
        especialidadRepository.deleteById(idEspecialidad);
    }
}package medisystem.avanzada.uq.citas_service.services.impl;

import medisystem.avanzada.uq.citas_service.dtos.eps.EpsRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.eps.EpsResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Eps;
import medisystem.avanzada.uq.citas_service.exceptions.EpsNoEncontradaException;
import medisystem.avanzada.uq.citas_service.exceptions.EpsYaExisteException; // Excepción necesaria
import medisystem.avanzada.uq.citas_service.mappers.EpsMapper;
import medisystem.avanzada.uq.citas_service.repositories.EpsRepository;
import medisystem.avanzada.uq.citas_service.services.EpsService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service("dbEpsService")
@Transactional
public class EpsServiceImpl implements EpsService {

    private final EpsRepository epsRepository;
    private final EpsMapper epsMapper; // Inyección del Mapper

    public EpsServiceImpl(EpsRepository epsRepository, EpsMapper epsMapper) {
        this.epsRepository = epsRepository;
        this.epsMapper = epsMapper;
    }

    // ========================================================
    // LECTURA (GET) - Ahora devuelve DTOs
    // ========================================================

    @Override
    @Transactional(readOnly = true)
    public List<EpsResponseDTO> getAllEps() {
        return epsRepository.findAll().stream()
                .map(epsMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    // CORREGIDO: int -> Long
    public EpsResponseDTO getEpsById(Long idEps) {
        Eps eps = epsRepository.findById(idEps)
                // Uso del constructor con Long
                .orElseThrow(() -> new EpsNoEncontradaException(idEps));

        return epsMapper.toResponseDTO(eps);
    }

    // ========================================================
    // CREACIÓN (POST) - Ahora usa DTOs y validación
    // ========================================================

    @Override
    public EpsResponseDTO postEps(EpsRequestDTO dto) {
        // Validación de Negocio: No debe existir otra con el mismo nombre
        if (epsRepository.existsByNombreEps(dto.getNombreEps())) {
            throw new EpsYaExisteException(dto.getNombreEps(), true);
        }

        Eps entity = epsMapper.toEntity(dto);
        Eps saved = epsRepository.save(entity);
        return epsMapper.toResponseDTO(saved);
    }

    // ========================================================
    // ACTUALIZACIÓN TOTAL (PUT) - Ahora usa DTOs y validación
    // ========================================================

    @Override
    // CORREGIDO: int -> Long, Eps -> EpsRequestDTO
    public EpsResponseDTO putEps(Long idEps, EpsRequestDTO dto) {
        Eps existente = epsRepository.findById(idEps)
                .orElseThrow(() -> new EpsNoEncontradaException(idEps));

        // Validación de Negocio: Si el nombre cambia, debe ser único
        if (!existente.getNombreEps().equalsIgnoreCase(dto.getNombreEps())) {
            if (epsRepository.existsByNombreEps(dto.getNombreEps())) {
                throw new EpsYaExisteException(dto.getNombreEps(), true);
            }
        }

        existente.setNombreEps(dto.getNombreEps());

        Eps actualizado = epsRepository.save(existente);
        return epsMapper.toResponseDTO(actualizado);
    }

    // ========================================================
    // ACTUALIZACIÓN PARCIAL (PATCH) - Ahora usa DTOs
    // ========================================================

    @Override
    // CORREGIDO: int -> Long, Eps -> EpsRequestDTO
    public EpsResponseDTO patchEps(Long idEps, EpsRequestDTO dto) {
        Eps existente = epsRepository.findById(idEps)
                .orElseThrow(() -> new EpsNoEncontradaException(idEps));

        if (dto.getNombreEps() != null) {
            // Validación de Negocio: Si el nombre cambia, debe ser único
            if (!existente.getNombreEps().equalsIgnoreCase(dto.getNombreEps())) {
                if (epsRepository.existsByNombreEps(dto.getNombreEps())) {
                    throw new EpsYaExisteException(dto.getNombreEps(), true);
                }
            }
            existente.setNombreEps(dto.getNombreEps());
        }

        Eps actualizado = epsRepository.save(existente);
        return epsMapper.toResponseDTO(actualizado);
    }

    // ========================================================
    // ELIMINACIÓN (DELETE)
    // ========================================================

    @Override
    // CORREGIDO: int -> Long
    public void deleteEps(Long idEps) {
        // Usamos existsById para validar antes de borrar
        if (!epsRepository.existsById(idEps)) {
            throw new EpsNoEncontradaException(idEps);
        }
        epsRepository.deleteById(idEps);
    }
}package medisystem.avanzada.uq.citas_service.services.impl;

import medisystem.avanzada.uq.citas_service.dtos.detalleFormula.DetalleFormulaRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.detalleFormula.DetalleFormulaResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.DetalleFormula;
import medisystem.avanzada.uq.citas_service.entities.Formula;
import medisystem.avanzada.uq.citas_service.entities.Medicamento;
import medisystem.avanzada.uq.citas_service.exceptions.DetalleFormulaNoEncontradaException;
import medisystem.avanzada.uq.citas_service.exceptions.FormulaNoEncontradaException;
import medisystem.avanzada.uq.citas_service.exceptions.MedicamentoNoEncontradoException;
import medisystem.avanzada.uq.citas_service.mappers.DetalleFormulaMapper;
import medisystem.avanzada.uq.citas_service.repositories.DetalleFormulaRepository;
import medisystem.avanzada.uq.citas_service.repositories.FormulaRepository;
import medisystem.avanzada.uq.citas_service.repositories.MedicamentoRepository;
import medisystem.avanzada.uq.citas_service.services.DetalleFormulaService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service("dbDetalleFormulaService")
@Transactional
public class DetalleFormulaServiceImpl implements DetalleFormulaService {

    private final DetalleFormulaRepository detalleFormulaRepository;
    private final FormulaRepository formulaRepository;
    private final MedicamentoRepository medicamentoRepository;
    private final DetalleFormulaMapper detalleFormulaMapper;

    public DetalleFormulaServiceImpl(DetalleFormulaRepository detalleFormulaRepository,
                                     FormulaRepository formulaRepository,
                                     MedicamentoRepository medicamentoRepository,
                                     DetalleFormulaMapper detalleFormulaMapper) {
        this.detalleFormulaRepository = detalleFormulaRepository;
        this.formulaRepository = formulaRepository;
        this.medicamentoRepository = medicamentoRepository;
        this.detalleFormulaMapper = detalleFormulaMapper;
    }

    // ========================================================
    // LECTURA (GET) - Corregido para usar Long
    // ========================================================

    @Override
    @Transactional(readOnly = true)
    public List<DetalleFormulaResponseDTO> getDetalleFormulas() {
        return detalleFormulaRepository.findAll()
                .stream()
                .map(detalleFormulaMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    // CORREGIDO: Integer -> Long
    public DetalleFormulaResponseDTO getDetalleFormulaById(Long idDetalleFormula) {
        DetalleFormula entity = detalleFormulaRepository.findById(idDetalleFormula)
                // Uso de la excepción con Long
                .orElseThrow(() -> new DetalleFormulaNoEncontradaException(idDetalleFormula));

        return detalleFormulaMapper.toResponseDTO(entity);
    }

    // ========================================================
    // MÉTODOS DE SOPORTE (Uso interno por FormulaService)
    // Estos métodos deberían ser llamados por FormulaService
    // ========================================================

    /**
     * Crea y asocia un DetalleFormula a una Formula existente.
     * Este método es llamado por FormulaServiceImpl.
     * @param idFormula ID de la fórmula contenedora.
     * @param dto Datos del medicamento.
     * @return DetalleFormulaResponseDTO
     */
    public DetalleFormulaResponseDTO createDetalleForFormula(Long idFormula, DetalleFormulaRequestDTO dto) {
        // 1. Buscar Fórmula
        Formula formula = formulaRepository.findById(idFormula)
                .orElseThrow(() -> new FormulaNoEncontradaException(idFormula));

        // 2. Buscar Medicamento
        Medicamento medicamento = medicamentoRepository.findById(dto.getIdMedicamento())
                .orElseThrow(() -> new MedicamentoNoEncontradoException(dto.getIdMedicamento()));

        // 3. Mapear y Guardar
        DetalleFormula entity = detalleFormulaMapper.toEntity(dto, formula, medicamento);
        DetalleFormula saved = detalleFormulaRepository.save(entity);

        return detalleFormulaMapper.toResponseDTO(saved);
    }

    // ========================================================
    // ACTUALIZACIÓN (PUT/PATCH/DELETE) - Basados en la interfaz original
    // ========================================================

    // NOTA: POST y PUT directo del DetalleFormula no tiene sentido de negocio,
    // pero los mantenemos para el contrato de la interfaz.

    @Override
    public DetalleFormulaResponseDTO postDetalleFormula(DetalleFormulaRequestDTO dto) {
        // Asumiendo que esta llamada viene de un contexto donde el ID de la fórmula
        // se maneja externamente o se pasa implícitamente.
        throw new UnsupportedOperationException("El método POST directo de DetalleFormula está deshabilitado. Use el servicio de Fórmula.");
    }

    @Override
    public DetalleFormulaResponseDTO putDetalleFormula(Long idDetalleFormula, DetalleFormulaRequestDTO dto) {
        // Lógica de PUT simplificada
        DetalleFormula existente = detalleFormulaRepository.findById(idDetalleFormula)
                .orElseThrow(() -> new DetalleFormulaNoEncontradaException(idDetalleFormula));

        // NOTA: Se evita buscar Formula y Medicamento aquí, ya que el put/patch de detalle
        // no debería ser la vía principal para cambiar el medicamento asociado.

        if (dto.getCantidad() != null) {
            existente.setCantidad(dto.getCantidad());
        }
        if (dto.getDosis() != null) {
            existente.setDosis(dto.getDosis());
        }

        DetalleFormula updated = detalleFormulaRepository.save(existente);
        return detalleFormulaMapper.toResponseDTO(updated);
    }

    @Override
    public void deleteDetalleFormula(Long idDetalleFormula) {
        if (!detalleFormulaRepository.existsById(idDetalleFormula)) {
            throw new DetalleFormulaNoEncontradaException(idDetalleFormula);
        }
        detalleFormulaRepository.deleteById(idDetalleFormula);
    }

    @Override
    public DetalleFormulaResponseDTO patchDetalleFormula(Long idDetalleFormula, DetalleFormulaRequestDTO dto) {
        // Lógica de PATCH simplificada
        DetalleFormula existente = detalleFormulaRepository.findById(idDetalleFormula)
                .orElseThrow(() -> new DetalleFormulaNoEncontradaException(idDetalleFormula));

        if (dto.getCantidad() != null) {
            existente.setCantidad(dto.getCantidad());
        }
        if (dto.getDosis() != null) {
            existente.setDosis(dto.getDosis());
        }

        DetalleFormula updated = detalleFormulaRepository.save(existente);
        return detalleFormulaMapper.toResponseDTO(updated);
    }
}package medisystem.avanzada.uq.citas_service.services.impl;

import medisystem.avanzada.uq.citas_service.dtos.cita.CitaRequestDTO;
import medisystem.avanzada.uq.citas_service.dtos.cita.CitaResponseDTO;
import medisystem.avanzada.uq.citas_service.entities.Cita;
import medisystem.avanzada.uq.citas_service.entities.Medico;
import medisystem.avanzada.uq.citas_service.entities.Paciente;
import medisystem.avanzada.uq.citas_service.exceptions.CitaConflictoHorarioException;
import medisystem.avanzada.uq.citas_service.exceptions.CitaNoEncontradaException;
import medisystem.avanzada.uq.citas_service.exceptions.MedicoNoEncontradoException;
import medisystem.avanzada.uq.citas_service.exceptions.PacienteNoEncontradoException;
import medisystem.avanzada.uq.citas_service.mappers.CitaMapper;
import medisystem.avanzada.uq.citas_service.repositories.CitaRepository;
import medisystem.avanzada.uq.citas_service.repositories.MedicoRepository;
import medisystem.avanzada.uq.citas_service.repositories.PacienteRepository;
import medisystem.avanzada.uq.citas_service.services.CitaService;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;
import java.util.stream.Collectors;

@Service("dbCitaService")
@Transactional
public class CitaServiceImpl implements CitaService {

    private static final LocalTime HORA_INICIO_CONSULTA = LocalTime.of(8, 0);
    private static final LocalTime HORA_FIN_CONSULTA = LocalTime.of(17, 0);
    private static final int LIMITE_CITAS_DIARIAS = 10;

    private final CitaRepository citaRepository;
    private final MedicoRepository medicoRepository;
    private final PacienteRepository pacienteRepository;
    private final CitaMapper citaMapper;

    // Inyección por Constructor
    public CitaServiceImpl(CitaRepository citaRepository,
                           MedicoRepository medicoRepository,
                           PacienteRepository pacienteRepository,
                           CitaMapper citaMapper) {
        this.citaRepository = citaRepository;
        this.medicoRepository = medicoRepository;
        this.pacienteRepository = pacienteRepository;
        this.citaMapper = citaMapper;
    }

    // ==========================================================
    // LÓGICA DE SEGURIDAD
    // ==========================================================
    private String getAuthenticatedUsername() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        return (auth != null) ? auth.getName() : null;
    }

    private void verificarAcceso(Cita cita) {
        String username = getAuthenticatedUsername();
        if (username == null) return;

        boolean esPaciente = cita.getPaciente().getUsuario().getUsername().equals(username);
        boolean esMedico = cita.getMedico().getUsuario().getUsername().equals(username);

        if (!esPaciente && !esMedico) {
            throw new AccessDeniedException("No tienes permiso para acceder a esta cita.");
        }
    }

    // ==========================================================
    // CREACIÓN / AGENDAMIENTO (POST)
    // ==========================================================

    @Override
    public CitaResponseDTO agendarCita(CitaRequestDTO dto) {
        // 1. Validar y Buscar Dependencias (Médico y Paciente)
        Medico medico = medicoRepository.findById(dto.getIdMedico())
                .orElseThrow(() -> new MedicoNoEncontradoException(dto.getIdMedico()));

        Paciente paciente = pacienteRepository.findById(dto.getIdPaciente())
                .orElseThrow(() -> new PacienteNoEncontradoException(dto.getIdPaciente()));

        // 2. Seguridad: Solo el paciente autenticado puede agendar su propia cita
        String username = getAuthenticatedUsername();
        if (!paciente.getUsuario().getUsername().equals(username)) {
            throw new AccessDeniedException("Solo puedes agendar tus propias citas.");
        }

        // 3. Aplicar Reglas de Agendamiento
        validarReglasDeAgendamiento(medico, dto);

        // 4. Mapear y Guardar
        Cita nuevaCita = citaMapper.toEntity(dto, medico, paciente);
        Cita savedCita = citaRepository.save(nuevaCita);

        // 5. Retornar DTO
        return citaMapper.toResponseDTO(savedCita);
    }

    // ==========================================================
    // LECTURA (GET)
    // ==========================================================

    @Override
    @Transactional(readOnly = true)
    public List<CitaResponseDTO> getAllCitas() {
        return citaRepository.findAll().stream()
                .map(citaMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public CitaResponseDTO getCitaById(Long idCita) {
        Cita cita = citaRepository.findById(idCita)
                .orElseThrow(() -> new CitaNoEncontradaException(idCita));

        verificarAcceso(cita);

        return citaMapper.toResponseDTO(cita);
    }

    @Override
    @Transactional(readOnly = true)
    // Devuelve el historial de citas de un paciente.
    public List<CitaResponseDTO> findByPaciente(Paciente paciente) {
        // Usa el repositorio para obtener las citas por entidad, luego mapea a DTO
        return citaRepository.findByPaciente(paciente).stream()
                .map(citaMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    // Devuelve la agenda de citas de un médico.
    public List<CitaResponseDTO> findByMedico(Medico medico) {
        // Usa el repositorio para obtener las citas por entidad, luego mapea a DTO
        return citaRepository.findByMedico(medico).stream()
                .map(citaMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    // ==========================================================
    // ACTUALIZACIÓN Y ELIMINACIÓN (PUT/PATCH/DELETE)
    // ==========================================================

    @Override
    public CitaResponseDTO updateCita(Long idCita, CitaRequestDTO dto) {
        Cita citaExistente = citaRepository.findById(idCita)
                .orElseThrow(() -> new CitaNoEncontradaException(idCita));

        verificarAcceso(citaExistente);

        // Validar la nueva hora y fecha
        validarReglasDeAgendamiento(citaExistente.getMedico(), dto);

        // Actualización completa
        citaExistente.setFecha(dto.getFecha());
        citaExistente.setHoraInicio(dto.getHoraInicio());
        citaExistente.setObservaciones(dto.getObservaciones());
        // La duración es de 1 hora
        citaExistente.setHoraFin(dto.getHoraInicio().plusHours(1));

        Cita updatedCita = citaRepository.save(citaExistente);
        return citaMapper.toResponseDTO(updatedCita);
    }

    @Override
    public CitaResponseDTO patchCita(Long idCita, CitaRequestDTO dto) {
        Cita existente = citaRepository.findById(idCita)
                .orElseThrow(() -> new CitaNoEncontradaException(idCita));
        verificarAcceso(existente);

        // Actualización parcial
        if (dto.getFecha() != null) existente.setFecha(dto.getFecha());
        if (dto.getHoraInicio() != null) {
            existente.setHoraInicio(dto.getHoraInicio());
            existente.setHoraFin(dto.getHoraInicio().plusHours(1));
        }
        if (dto.getObservaciones() != null) existente.setObservaciones(dto.getObservaciones());

        // Volver a validar reglas si se modificó el horario
        if (dto.getFecha() != null || dto.getHoraInicio() != null) {
            validarReglasDeAgendamiento(existente.getMedico(), dto);
        }

        Cita updatedCita = citaRepository.save(existente);
        return citaMapper.toResponseDTO(updatedCita);
    }

    @Override
    public void deleteCita(Long idCita) {
        Cita cita = citaRepository.findById(idCita)
                .orElseThrow(() -> new CitaNoEncontradaException(idCita));

        verificarAcceso(cita);

        // Regla de negocio: solo se puede cancelar con un día de anticipación
        if (!cita.getFecha().isAfter(LocalDate.now())) {
            throw new CitaConflictoHorarioException("Solo puede cancelar citas con al menos un día de anticipación.");
        }

        citaRepository.delete(cita);
    }

    // ==========================================================
    // MÉTODOS PRIVADOS DE VALIDACIÓN
    // ==========================================================

    private void validarReglasDeAgendamiento(Medico medico, CitaRequestDTO dto) {

        if (dto.getFecha().isBefore(java.time.LocalDate.now())) {
            throw new CitaConflictoHorarioException("No se pueden agendar citas en fechas pasadas.");
        }

        if (dto.getFecha().getDayOfWeek() == DayOfWeek.SATURDAY ||
                dto.getFecha().getDayOfWeek() == DayOfWeek.SUNDAY) {
            throw new CitaConflictoHorarioException("No se pueden agendar citas los fines de semana.");
        }

        // Asumiendo que la duración de la cita es de 1 hora
        LocalTime horaFinEstimada = dto.getHoraInicio().plusHours(1);

        if (dto.getHoraInicio().isBefore(HORA_INICIO_CONSULTA) ||
                horaFinEstimada.isAfter(HORA_FIN_CONSULTA.plusHours(1))) {
            throw new CitaConflictoHorarioException("Las citas deben ser agendadas entre las 8:00 y 17:00.");
        }

        // Validación de conflicto de horario (Médico ocupado)
        boolean yaExiste = citaRepository.existsByMedicoAndFechaAndHoraInicio(
                medico, dto.getFecha(), dto.getHoraInicio());

        if (yaExiste) {
            throw new CitaConflictoHorarioException(
                    "El Dr/a. " + medico.getNombreMedico() + " ya tiene una cita agendada a las " +
                            dto.getHoraInicio() + " el día " + dto.getFecha() + ".");
        }

        // Validación de límite de citas diarias (Máximo 10)
        long citasDia = citaRepository.countByMedicoAndFecha(medico, dto.getFecha());
        if (citasDia >= LIMITE_CITAS_DIARIAS) {
            throw new CitaConflictoHorarioException(
                    "El Dr/a. " + medico.getNombreMedico() + " ha alcanzado el límite de " + LIMITE_CITAS_DIARIAS + " citas para el día " + dto.getFecha() + ".");
        }
    }
}package medisystem.avanzada.uq.citas_service.security;

import java.util.List;

public class UsuarioJson {
    private String username;
    private String password;
    private List<String> roles;

    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public List<String> getRoles() {
        return roles;
    }
    public void setRoles(List<String> roles) {
        this.roles = roles;
    }
}
package medisystem.avanzada.uq.citas_service.security;

import medisystem.avanzada.uq.citas_service.security.jwt.JwtAuthenticationFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.config.core.GrantedAuthorityDefaults; // 🌟 Nuevo Import

// Importaciones requeridas para el PasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;


@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(AbstractHttpConfigurer::disable)
                // Es crucial configurar el manejo de sesión como STATELESS para una API con JWT
                .sessionManagement(sess -> sess.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        // 🔓 Swagger y documentación
                        .requestMatchers(
                                "/swagger-ui.html",
                                "/swagger-ui/**",
                                "/v3/api-docs/**",
                                "/v3/api-docs.yaml",
                                "/v3/api-docs.json"
                        ).permitAll()

                        // 🔓 Autenticación pública (Ej: /sistema/api/v1/auth/login)
                        .requestMatchers("/auth/**").permitAll()

                        // 🔒 Reglas específicas por rol (Los nombres en BD: ADMINISTRADOR, MEDICO, PACIENTE)
                        .requestMatchers(
                                "/medicos/**",
                                "/pacientes/**",
                                "/telefonos/**",
                                "/usuarios/**"
                        ).hasRole("ADMINISTRADOR")
                        .requestMatchers(
                                "/eps/**",
                                "/especialidades/**",
                                "/medicamentos/**"
                        ).hasAnyRole("MEDICO", "ADMINISTRADOR")
                        .requestMatchers(
                                "/citas/**",
                                "/formulas/**",
                                "/detalle-formulas/**"
                        ).hasAnyRole("PACIENTE", "MEDICO", "ADMINISTRADOR")

                        // 🔒 Todo lo demás requiere autenticación
                        .anyRequest().authenticated()
                )
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) throws Exception {
        return configuration.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * Bean clave: Le dice a Spring Security que use una cadena vacía ("") como prefijo de autoridad.
     * Esto hace que hasRole("ADMINISTRADOR") coincida EXACTAMENTE con el rol "ADMINISTRADOR" de la BD,
     * respetando la restricción de tu base de datos.
     */
    @Bean
    public GrantedAuthorityDefaults grantedAuthorityDefaults() {
        return new GrantedAuthorityDefaults("");
    }
}
package medisystem.avanzada.uq.citas_service.security;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import medisystem.avanzada.uq.citas_service.entities.Rol;
import medisystem.avanzada.uq.citas_service.entities.RolNombre;
import medisystem.avanzada.uq.citas_service.entities.Usuario;
import medisystem.avanzada.uq.citas_service.repositories.RolRepository;
import medisystem.avanzada.uq.citas_service.repositories.UsuarioRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import java.io.InputStream;
import java.util.List;

@Component("dataInitializerSecurity")
public class DataInitializer {

    @Bean
    CommandLineRunner initData(UsuarioRepository usuarioRepository,
                               RolRepository rolRepository,
                               PasswordEncoder passwordEncoder) {
        return args -> {
            ObjectMapper mapper = new ObjectMapper();
            TypeReference<List<UsuarioJson>> typeRef = new TypeReference<>() {};

            try (InputStream inputStream = getClass().getResourceAsStream("/data/usuarios.json")) {
                if (inputStream == null) {
                    System.err.println(" ❌ No se encontró el archivo usuarios.json");
                    return;
                }

                List<UsuarioJson> usuariosJson = mapper.readValue(inputStream, typeRef);

                for (UsuarioJson u : usuariosJson) {
                    if (usuarioRepository.existsByUsername(u.getUsername())) continue;

                    Usuario usuario = new Usuario();
                    usuario.setUsername(u.getUsername());
                    usuario.setPassword(passwordEncoder.encode(u.getPassword()));

                    for (String rolNombreStr : u.getRoles()) {
                        try {
                            // Convertir el texto del JSON al enum correspondiente
                            RolNombre rolNombre = RolNombre.valueOf(rolNombreStr.toUpperCase());
                            Rol rol = rolRepository.findByNombre(rolNombre)
                                    .orElseGet(() -> rolRepository.save(new Rol(rolNombre)));
                            usuario.getRoles().add(rol);
                        } catch (IllegalArgumentException ex) {
                            System.err.println(" ⚠️ Rol no válido en JSON: " + rolNombreStr);
                        }
                    }

                    usuarioRepository.save(usuario);
                    System.out.println("✅ Usuario creado: " + u.getUsername());
                }

            } catch (Exception e) {
                e.printStackTrace();
            }
        };
    }
}
-- Inserción de EPS
INSERT INTO eps (nombre_eps) VALUES
('SURA'),
('Nueva EPS'),
('Salud Total'),
('Compensar'),
('Medimás'),
('Famisanar'),
('Coomeva'),
('Sanitas'),
('Aliansalud'),
('Nueva Alianza');

-- Inserción de Especialidades
INSERT INTO especialidades (nombre_especialidad) VALUES
('Medicina General'),
('Cardiología'),
('Pediatría'),
('Ginecología'),
('Oftalmología'),
('Dermatología'),
('Traumatología'),
('Neurología'),
('Psiquiatría'),
('Urología');

-- INSERCIÓN  NUEVOS USUARIOS MÉDICOS
INSERT INTO usuarios (username, password) VALUES
('doc_sanchez', '1234'),
('doc_ramirez', '1234'),
('doc_gomez', '1234'),
('doc_rojas', '1234'),
('doc_cruz', '1234'),
('doc_perez', '1234'),
('doc_arias', '1234'),
('doc_mora', '1234');


--  INSERCIÓN NUEVOS USUARIOS PACIENTES
INSERT INTO usuarios (username, password) VALUES
('pac_diaz', '1234'), -- ID 13
('pac_garcia', '1234'),
('pac_lopez', '1234'),
('pac_fernandez', '1234'),
('pac_martinez', '1234'),
('pac_hernandez', '1234'),
('pac_gonzalez', '1234'),
('pac_alvarez', '1234'),
('pac_romero', '1234'),
('pac_ruiz', '1234'),
('pac_torres', '1234'),
('pac_flores', '1234'),
('pac_rivera', '1234'),
('pac_castro', '1234'),
('pac_silva', '1234'),
('pac_vargas', '1234'),
('pac_mendez', '1234'),
('pac_nuñez', '1234'),
('pac_ortiz', '1234'),
('pac_ramos', '1234'),
('pac_soto', '1234'),
('pac_vega', '1234'),
('pac_cortez', '1234'),
('pac_benitez', '1234'),
('pac_marquez', '1234'),
('pac_guerrero', '1234'),
('pac_quintero', '1234'),
('pac_navarro', '1234'),
('pac_rios', '1234'),
('pac_zuniga', '1234');

-- Asocia a los 8 nuevos médicos (IDs 5 a 12) al rol MEDICO (ID 2)
INSERT INTO usuarios_roles (id_usuario, id_rol)
SELECT id_usuario, (SELECT id_rol FROM roles WHERE nombre = 'MEDICO')
FROM usuarios
WHERE id_usuario BETWEEN 5 AND 12;

-- Asocia a los 30 nuevos pacientes (IDs 13 a 42) al rol PACIENTE (ID 3)
INSERT INTO usuarios_roles (id_usuario, id_rol)
SELECT id_usuario, (SELECT id_rol FROM roles WHERE nombre = 'PACIENTE')
FROM usuarios
WHERE id_usuario BETWEEN 13 AND 42;

-- Ivan Bañol (ID_USUARIO = 2) - Asignado a Pediatría
INSERT INTO medicos (id_medico, nombre_medico, correo, telefono, id_especialidad, id_usuario)
VALUES (
    (SELECT id_usuario FROM usuarios WHERE username = 'ivan'), -- id_medico (PK y FK a usuarios)
    'Dr. Ivan Bañol',
    'ivan.banol@medisystem.com',
    '3101230002',
    (SELECT id_especialidad FROM especialidades WHERE nombre_especialidad = 'Pediatría'),
    (SELECT id_usuario FROM usuarios WHERE username = 'ivan')
);

-- Jorge Quintero (ID_USUARIO = 4) - Asignado a Cardiología
INSERT INTO medicos (id_medico, nombre_medico, correo, telefono, id_especialidad, id_usuario)
VALUES (
    (SELECT id_usuario FROM usuarios WHERE username = 'jorge'),
    'Dr. Jorge Quintero',
    'jorge.quintero@medisystem.com',
    '3204560004',
    (SELECT id_especialidad FROM especialidades WHERE nombre_especialidad = 'Cardiología'),
    (SELECT id_usuario FROM usuarios WHERE username = 'jorge')
);

-- NOTA: Se asume que la columna FK a usuarios es 'id_usuario', y la PK es 'id_medico'.
-- Se usa la columna 'nombre_especialidad' en la tabla 'especialidades'.

-- 3. doc_sanchez (ID 5) - Oftalmología
INSERT INTO medicos (id_medico, nombre_medico, correo, telefono, id_especialidad, id_usuario)
VALUES (
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_sanchez'),
    'Dra. Sofía Sánchez',
    'sofia.sanchez@medisystem.com',
    '3157890005',
    (SELECT id_especialidad FROM especialidades WHERE nombre_especialidad = 'Oftalmología'),
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_sanchez')
);

-- 4. doc_ramirez (ID 6) - Dermatología
INSERT INTO medicos (id_medico, nombre_medico, correo, telefono, id_especialidad, id_usuario)
VALUES (
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_ramirez'),
    'Dr. Ricardo Ramírez',
    'ricardo.ramirez@medisystem.com',
    '3001120006',
    (SELECT id_especialidad FROM especialidades WHERE nombre_especialidad = 'Dermatología'),
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_ramirez')
);

-- 5. doc_gomez (ID 7) - Traumatología
INSERT INTO medicos (id_medico, nombre_medico, correo, telefono, id_especialidad, id_usuario)
VALUES (
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_gomez'),
    'Dra. Gabriela Gómez',
    'gabriela.gomez@medisystem.com',
    '3104450007',
    (SELECT id_especialidad FROM especialidades WHERE nombre_especialidad = 'Traumatología'),
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_gomez')
);

-- 6. doc_rojas (ID 8) - Neurología
INSERT INTO medicos (id_medico, nombre_medico, correo, telefono, id_especialidad, id_usuario)
VALUES (
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_rojas'),
    'Dr. Roberto Rojas',
    'roberto.rojas@medisystem.com',
    '3017780008',
    (SELECT id_especialidad FROM especialidades WHERE nombre_especialidad = 'Neurología'),
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_rojas')
);

-- 7. doc_cruz (ID 9) - Psiquiatría
INSERT INTO medicos (id_medico, nombre_medico, correo, telefono, id_especialidad, id_usuario)
VALUES (
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_cruz'),
    'Dra. Camila Cruz',
    'camila.cruz@medisystem.com',
    '3120010009',
    (SELECT id_especialidad FROM especialidades WHERE nombre_especialidad = 'Psiquiatría'),
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_cruz')
);

-- 8. doc_perez (ID 10) - Urología
INSERT INTO medicos (id_medico, nombre_medico, correo, telefono, id_especialidad, id_usuario)
VALUES (
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_perez'),
    'Dra. Patricia Pérez',
    'patricia.perez@medisystem.com',
    '3183340010',
    (SELECT id_especialidad FROM especialidades WHERE nombre_especialidad = 'Urología'),
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_perez')
);

-- 9. doc_arias (ID 11) - Medicina General
INSERT INTO medicos (id_medico, nombre_medico, correo, telefono, id_especialidad, id_usuario)
VALUES (
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_arias'),
    'Dr. Andrés Arias',
    'andres.arias@medisystem.com',
    '3166670011',
    (SELECT id_especialidad FROM especialidades WHERE nombre_especialidad = 'Medicina General'),
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_arias')
);

-- 10. doc_mora (ID 12) - Ginecología
INSERT INTO medicos (id_medico, nombre_medico, correo, telefono, id_especialidad, id_usuario)
VALUES (
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_mora'),
    'Dr. Marcelo Mora',
    'marcelo.mora@medisystem.com',
    '3149900012',
    (SELECT id_especialidad FROM especialidades WHERE nombre_especialidad = 'Ginecología'),
    (SELECT id_usuario FROM usuarios WHERE username = 'doc_mora')
);



-- 1. Cristian (ID_USUARIO = 3)
INSERT INTO pacientes (id_paciente, nombre_paciente, correo, ciudad, id_eps, id_usuario)
VALUES (
    '1000000003', -- Identificación/Cédula
    'Cristian Castaño',
    'cristian.Castano@mail.com',
    'Armenia',
    (SELECT id_eps FROM eps WHERE nombre_eps  = 'SURA'),
    (SELECT id_usuario FROM usuarios WHERE username = 'cristian')
);

-- 2. Nuevos Pacientes (IDs de Usuario 13 a 42)
INSERT INTO pacientes (id_paciente, nombre_paciente, correo, ciudad, id_eps, id_usuario)
VALUES
-- Bloque 1 (Usuarios 13-22)
( '1000000013', 'Diego Díaz', 'p13@mail.com', 'Cali', (SELECT id_eps FROM eps WHERE nombre_eps = 'Nueva EPS'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_diaz') ),
( '1000000014', 'Laura García', 'p14@mail.com', 'Cali', (SELECT id_eps FROM eps WHERE nombre_eps = 'Salud Total'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_garcia') ),
( '1000000015', 'Carlos López', 'p15@mail.com', 'Pereira', (SELECT id_eps FROM eps WHERE nombre_eps = 'Compensar'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_lopez') ),
( '1000000016', 'Ana Fernández', 'p16@mail.com', 'Pereira', (SELECT id_eps FROM eps WHERE nombre_eps = 'Medimás'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_fernandez') ),
( '1000000017', 'Luis Martínez', 'p17@mail.com', 'Manizales', (SELECT id_eps FROM eps WHERE nombre_eps = 'Famisanar'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_martinez') ),
( '1000000018', 'Sara Hernández', 'p18@mail.com', 'Manizales', (SELECT id_eps FROM eps WHERE nombre_eps = 'Coomeva'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_hernandez') ),
( '1000000019', 'Pedro González', 'p19@mail.com', 'Bogotá', (SELECT id_eps FROM eps WHERE nombre_eps = 'Sanitas'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_gonzalez') ),
( '1000000020', 'Marta Álvarez', 'p20@mail.com', 'Bogotá', (SELECT id_eps FROM eps WHERE nombre_eps = 'Aliansalud'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_alvarez') ),
( '1000000021', 'Javier Romero', 'p21@mail.com', 'Medellín', (SELECT id_eps FROM eps WHERE nombre_eps = 'Nueva Alianza'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_romero') ),
( '1000000022', 'Elena Ruiz', 'p22@mail.com', 'Medellín', (SELECT id_eps FROM eps WHERE nombre_eps = 'SURA'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_ruiz') ),

-- Bloque 2 (Usuarios 23-32)
( '1000000023', 'Andrés Torres', 'p23@mail.com', 'Bucaramanga', (SELECT id_eps FROM eps WHERE nombre_eps = 'Nueva EPS'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_torres') ),
( '1000000024', 'Sofía Flores', 'p24@mail.com', 'Bucaramanga', (SELECT id_eps FROM eps WHERE nombre_eps = 'Salud Total'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_flores') ),
( '1000000025', 'Ricardo Rivera', 'p25@mail.com', 'Cartagena', (SELECT id_eps FROM eps WHERE nombre_eps = 'Compensar'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_rivera') ),
( '1000000026', 'Valeria Castro', 'p26@mail.com', 'Cartagena', (SELECT id_eps FROM eps WHERE nombre_eps = 'Medimás'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_castro') ),
( '1000000027', 'Felipe Silva', 'p27@mail.com', 'Barranquilla', (SELECT id_eps FROM eps WHERE nombre_eps = 'Famisanar'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_silva') ),
( '1000000028', 'Catalina Vargas', 'p28@mail.com', 'Barranquilla', (SELECT id_eps FROM eps WHERE nombre_eps = 'Coomeva'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_vargas') ),
( '1000000029', 'Gabriel Méndez', 'p29@mail.com', 'Cúcuta', (SELECT id_eps FROM eps WHERE nombre_eps = 'Sanitas'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_mendez') ),
( '1000000030', 'Isabella Núñez', 'p30@mail.com', 'Cúcuta', (SELECT id_eps FROM eps WHERE nombre_eps = 'Aliansalud'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_nuñez') ),
( '1000000031', 'Omar Ortiz', 'p31@mail.com', 'Ibagué', (SELECT id_eps FROM eps WHERE nombre_eps = 'Nueva Alianza'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_ortiz') ),
( '1000000032', 'Natalia Ramos', 'p32@mail.com', 'Ibagué', (SELECT id_eps FROM eps WHERE nombre_eps = 'SURA'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_ramos') ),

-- Bloque 3 (Usuarios 33-42)
( '1000000033', 'Pablo Soto', 'p33@mail.com', 'Pasto', (SELECT id_eps FROM eps WHERE nombre_eps = 'Nueva EPS'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_soto') ),
( '1000000034', 'Juliana Vega', 'p34@mail.com', 'Pasto', (SELECT id_eps FROM eps WHERE nombre_eps = 'Salud Total'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_vega') ),
( '1000000035', 'Esteban Cortez', 'p35@mail.com', 'Neiva', (SELECT id_eps FROM eps WHERE nombre_eps = 'Compensar'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_cortez') ),
( '1000000036', 'Daniela Benítez', 'p36@mail.com', 'Neiva', (SELECT id_eps FROM eps WHERE nombre_eps = 'Medimás'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_benitez') ),
( '1000000037', 'Camilo Márquez', 'p37@mail.com', 'Villavicencio', (SELECT id_eps FROM eps WHERE nombre_eps = 'Famisanar'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_marquez') ),
( '1000000038', 'Alejandra Guerrero', 'p38@mail.com', 'Villavicencio', (SELECT id_eps FROM eps WHERE nombre_eps = 'Coomeva'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_guerrero') ),
( '1000000039', 'Miguel Quintero', 'p39@mail.com', 'Popayán', (SELECT id_eps FROM eps WHERE nombre_eps = 'Sanitas'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_quintero') ),
( '1000000040', 'Vanessa Navarro', 'p40@mail.com', 'Popayán', (SELECT id_eps FROM eps WHERE nombre_eps = 'Aliansalud'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_navarro') ),
( '1000000041', 'Hector Ríos', 'p41@mail.com', 'Tunja', (SELECT id_eps FROM eps WHERE nombre_eps = 'Nueva Alianza'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_rios') ),
( '1000000042', 'Jessica Zúñiga', 'p42@mail.com', 'Tunja', (SELECT id_eps FROM eps WHERE nombre_eps = 'SURA'), (SELECT id_usuario FROM usuarios WHERE username = 'pac_zuniga') );


INSERT INTO medicamentos (nombre_medicamento, precio) VALUES
('Acetaminofén 500mg', 2800.00),
('Ibuprofeno 400mg', 4500.00),
('Diclofenaco Sódico 75mg', 8000.00),
('Naproxeno 500mg', 12000.00),
('Tramadol 50mg', 25000.00),
('Metamizol Sódico 500mg', 6000.00),
('Celecoxib 200mg', 48000.00),
('Ketorolaco 10mg', 15000.00),
('Paracetamol Jarabe', 18000.00),
('Meloxicam 15mg', 22000.00), -- Fin Analgésicos/Antiinflamatorios (1-10)

('Amoxicilina 500mg', 18000.00),
('Ciprofloxacino 500mg', 35000.00),
('Azitromicina 500mg', 55000.00),
('Clindamicina 300mg', 42000.00),
('Metronidazol 500mg', 20000.00),
('Fluconazol 150mg', 48000.00),
('Cefalexina 500mg', 30000.00),
('Doxiciclina 100mg', 24000.00),
('Penicilina Benzatínica', 75000.00),
('Levofloxacino 750mg', 60000.00), -- Fin Antibióticos (11-20)

('Omeprazol 20mg', 23000.00),
('Lansoprazol 30mg', 28000.00),
('Ranitidina 150mg', 15000.00),
('Loperamida 2mg', 14000.00),
('Buscapina Compuesta', 20000.00),
('Domperidona 10mg', 17000.00),
('Lactulosa Jarabe', 40000.00),
('Esomeprazol 40mg', 45000.00),
('Metoclopramida 10mg', 13000.00),
('Sales de Rehidratación Oral', 9000.00), -- Fin Gastrointestinales (21-30)

('Loratadina 10mg', 10000.00),
('Cetirizina 10mg', 12000.00),
('Dexametasona 4mg', 15000.00),
('Salbutamol Inhalador', 65000.00),
('Montelukast 10mg', 50000.00),
('Ambroxol Jarabe', 22000.00),
('Pseudoefedrina 60mg', 18000.00),
('Fluticasona Nasal Spray', 55000.00),
('Budesonida Suspensión', 45000.00),
('Codeína 10mg', 28000.00), -- Fin Respiratorios (31-40)

('Losartán 50mg', 32000.00),
('Amlodipino 5mg', 30000.00),
('Metformina 850mg', 25000.00),
('Atorvastatina 20mg', 40000.00),
('Captopril 25mg', 15000.00),
('Clopidogrel 75mg', 60000.00),
('Simvastatina 40mg', 35000.00),
('Furosemida 40mg', 14000.00),
('Insulina NPH', 120000.00),
('Warfarina 5mg', 50000.00); -- Fin Cardiovasculares (41-50)


-- 1. INSERCIÓN DE 50 NÚMEROS DE TELÉFONO DE 10 DÍGITOS
INSERT INTO telefonos (telefono) VALUES
('3000000001'), ('3000000002'), ('3000000003'), ('3000000004'), ('3000000005'),
('3000000006'), ('3000000007'), ('3000000008'), ('3000000009'), ('3000000010'),
('3000000011'), ('3000000012'), ('3000000013'), ('3000000014'), ('3000000015'),
('3000000016'), ('3000000017'), ('3000000018'), ('3000000019'), ('3000000020'),
('3000000021'), ('3000000022'), ('3000000023'), ('3000000024'), ('3000000025'),
('3000000026'), ('3000000027'), ('3000000028'), ('3000000029'), ('3000000030'),
('3000000031'), ('3000000032'), ('3000000033'), ('3000000034'), ('3000000035'),
('3000000036'), ('3000000037'), ('3000000038'), ('3000000039'), ('3000000040'),
('3000000041'), ('3000000042'), ('3000000043'), ('3000000044'), ('3000000045'),
('3000000046'), ('3000000047'), ('3000000048'), ('3000000049'), ('3000000050');



-- *** 3. REASIGNACIÓN DE TELÉFONOS (31 base + 17 adicionales) ***
INSERT INTO pacientes_telefonos (id_telefono, id_paciente) VALUES
-- Asignación base (31 registros)
( 1, '1000000003'), ( 2, '1000000013'), ( 3, '1000000014'), ( 4, '1000000015'), ( 5, '1000000016'),
( 6, '1000000017'), ( 7, '1000000018'), ( 8, '1000000019'), ( 9, '1000000020'), ( 10, '1000000021'),
( 11, '1000000022'), ( 12, '1000000023'), ( 13, '1000000024'), ( 14, '1000000025'), ( 15, '1000000026'),
( 16, '1000000027'), ( 17, '1000000028'), ( 18, '1000000029'), ( 19, '1000000030'), ( 20, '1000000031'),
( 21, '1000000032'), ( 22, '1000000033'), ( 23, '1000000034'), ( 24, '1000000035'), ( 25, '1000000036'),
( 26, '1000000037'), ( 27, '1000000038'), ( 28, '1000000039'), ( 29, '1000000040'), ( 30, '1000000041'),
( 31, '1000000042'),

-- Asignación de teléfonos adicionales (17 registros)
( 32, '1000000003' ), ( 33, '1000000003' ),
( 34, '1000000013' ),
( 35, '1000000014' ), ( 36, '1000000014' ),
( 37, '1000000015' ),
( 38, '1000000016' ), ( 39, '1000000016' ),
( 40, '1000000017' ),
( 41, '1000000018' ), ( 42, '1000000018' ),
( 43, '1000000019' ),
( 44, '1000000020' ), ( 45, '1000000020' ),
( 46, '1000000021' ),
( 47, '1000000022' ), ( 48, '1000000022' );





INSERT INTO citas (fecha, hora_inicio, hora_fin, observaciones, estado, id_paciente, id_medico)
VALUES
-- 1. Pasada (FINALIZADA) - Cristian Castaño
('2025-10-15', '10:00:00', '10:30:00', 'Revisión pediátrica, 24 horas después de vacuna.', 'FINALIZADA',
 (SELECT id_paciente FROM pacientes WHERE nombre_paciente = 'Cristian Castaño'),
 (SELECT id_medico FROM medicos WHERE nombre_medico = 'Dr. Ivan Bañol')),

-- 2. Presente (AGENDADA) - Diego Díaz
('2025-10-16', '14:00:00', '14:30:00', 'Control de tensión arterial. Cita vespertina de hoy.', 'AGENDADA',
 (SELECT id_paciente FROM pacientes WHERE nombre_paciente = 'Diego Díaz'),
 (SELECT id_medico FROM medicos WHERE nombre_medico = 'Dr. Jorge Quintero')),

-- 3. Pasada (FINALIZADA) - Laura García
('2025-10-10', '09:30:00', '10:00:00', 'Consulta por dolor de espalda. Se recomienda fisioterapia.', 'FINALIZADA',
 (SELECT id_paciente FROM pacientes WHERE nombre_paciente = 'Laura García'),
 (SELECT id_medico FROM medicos WHERE nombre_medico = 'Dra. Sofía Sánchez')),

-- 4. Futura (AGENDADA) - Carlos López
('2025-10-17', '11:00:00', '11:30:00', 'Chequeo general de rutina. Mañana a primera hora.', 'AGENDADA',
 (SELECT id_paciente FROM pacientes WHERE nombre_paciente = 'Carlos López'),
 (SELECT id_medico FROM medicos WHERE nombre_medico = 'Dr. Ricardo Ramírez')),

-- 5. Futura (AGENDADA) - Ana Fernández
('2025-10-25', '08:30:00', '09:00:00', 'Revisión de glucosa. Cita de final de mes.', 'AGENDADA',
 (SELECT id_paciente FROM pacientes WHERE nombre_paciente = 'Ana Fernández'),
 (SELECT id_medico FROM medicos WHERE nombre_medico = 'Dra. Gabriela Gómez')),

-- 6. Pasada (FINALIZADA) - Luis Martínez
('2025-10-14', '16:00:00', '16:30:00', 'Consulta por vértigo. Se emite fórmula.', 'FINALIZADA',
 (SELECT id_paciente FROM pacientes WHERE nombre_paciente = 'Luis Martínez'),
 (SELECT id_medico FROM medicos WHERE nombre_medico = 'Dr. Roberto Rojas')),

-- 7. Presente (AGENDADA) - Sara Hernández
('2025-10-16', '17:00:00', '17:30:00', 'Examen de la vista. Cita de la tarde.', 'AGENDADA',
 (SELECT id_paciente FROM pacientes WHERE nombre_paciente = 'Sara Hernández'),
 (SELECT id_medico FROM medicos WHERE nombre_medico = 'Dra. Camila Cruz')),

-- 8. Futura (AGENDADA) - Pedro González
('2025-11-01', '16:30:00', '17:00:00', 'Control trimestral de ácido úrico.', 'AGENDADA',
 (SELECT id_paciente FROM pacientes WHERE nombre_paciente = 'Pedro González'),
 (SELECT id_medico FROM medicos WHERE nombre_medico = 'Dra. Patricia Pérez')),

-- 9. Pasada (FINALIZADA) - Marta Álvarez
('2025-10-05', '11:30:00', '12:00:00', 'Evaluación de depresión. Ajuste de dosis.', 'FINALIZADA',
 (SELECT id_paciente FROM pacientes WHERE nombre_paciente = 'Marta Álvarez'),
 (SELECT id_medico FROM medicos WHERE nombre_medico = 'Dr. Andrés Arias')),

-- 10. Futura (AGENDADA) - Javier Romero
('2025-10-18', '10:00:00', '10:30:00', 'Consulta preventiva. Sábado en la mañana.', 'AGENDADA',
 (SELECT id_paciente FROM pacientes WHERE nombre_paciente = 'Javier Romero'),
 (SELECT id_medico FROM medicos WHERE nombre_medico = 'Dr. Marcelo Mora'));


 -- *** 2. INSERCIÓN DE 8 FÓRMULAS MÉDICAS (SIN OBSERVACIONES) ***

 INSERT INTO formulas (id_cita, fecha)
 VALUES
 -- FÓRMULA 1 (Cita ID 1: 2025-10-15 - Cristian Castaño)
 ( (SELECT id_cita FROM citas WHERE id_paciente = '1000000003' AND fecha = '2025-10-15'), '2025-10-15' ),

 -- FÓRMULA 2 (Cita ID 3: 2025-10-10 - Laura García)
 ( (SELECT id_cita FROM citas WHERE id_paciente = '1000000014' AND fecha = '2025-10-10'), '2025-10-10' ),

 -- FÓRMULA 3 (Cita ID 6: 2025-10-14 - Luis Martínez)
 ( (SELECT id_cita FROM citas WHERE id_paciente = '1000000017' AND fecha = '2025-10-14'), '2025-10-14' ),

 -- FÓRMULA 4 (Cita ID 9: 2025-10-05 - Marta Álvarez)
 ( (SELECT id_cita FROM citas WHERE id_paciente = '1000000020' AND fecha = '2025-10-05'), '2025-10-05' ),

 -- FÓRMULA 5 (Cita ID 11: 2025-10-26 - Elena Ruiz)
 ( (SELECT id_cita FROM citas WHERE id_paciente = '1000000022' AND fecha = '2025-10-26'), '2025-10-26' ),

 -- FÓRMULA 6 (Cita ID 13: 2025-10-15 - Sofía Flores)
 ( (SELECT id_cita FROM citas WHERE id_paciente = '1000000024' AND fecha = '2025-10-15'), '2025-10-15' ),

 -- FÓRMULA 7 (Cita ID 16: 2025-10-25 - Felipe Silva)
 ( (SELECT id_cita FROM citas WHERE id_paciente = '1000000027' AND fecha = '2025-10-25'), '2025-10-25' ),

 -- FÓRMULA 8 (Cita ID 19: 2025-10-18 - Isabella Núñez)
 ( (SELECT id_cita FROM citas WHERE id_paciente = '1000000030' AND fecha = '2025-10-18'), '2025-10-18' );



-- *** 1. LIMPIEZA INICIAL DE TABLAS ***
TRUNCATE TABLE detalle_formula RESTART IDENTITY CASCADE;
TRUNCATE TABLE formulas RESTART IDENTITY CASCADE;
-- Asumimos que las 10 citas del 16 de octubre ya están en la tabla 'citas'.

-- *** 2. INSERCIÓN DE 8 FÓRMULAS MÉDICAS (Solo id_cita y fecha) ***
INSERT INTO formulas (id_cita, fecha)
VALUES
-- FÓRMULA 1 (Cita ID 1: 2025-10-15 - Cristian Castaño)
( (SELECT id_cita FROM citas WHERE id_paciente = '1000000003' AND fecha = '2025-10-15'), '2025-10-15' ),
-- FÓRMULA 2 (Cita ID 3: 2025-10-10 - Laura García)
( (SELECT id_cita FROM citas WHERE id_paciente = '1000000014' AND fecha = '2025-10-10'), '2025-10-10' ),
-- FÓRMULA 3 (Cita ID 6: 2025-10-14 - Luis Martínez)
( (SELECT id_cita FROM citas WHERE id_paciente = '1000000017' AND fecha = '2025-10-14'), '2025-10-14' ),
-- FÓRMULA 4 (Cita ID 9: 2025-10-05 - Marta Álvarez)
( (SELECT id_cita FROM citas WHERE id_paciente = '1000000020' AND fecha = '2025-10-05'), '2025-10-05' ),
-- FÓRMULA 5 (Cita ID 11: 2025-10-26 - Elena Ruiz)
( (SELECT id_cita FROM citas WHERE id_paciente = '1000000022' AND fecha = '2025-10-26'), '2025-10-26' ),
-- FÓRMULA 6 (Cita ID 13: 2025-10-15 - Sofía Flores)
( (SELECT id_cita FROM citas WHERE id_paciente = '1000000024' AND fecha = '2025-10-15'), '2025-10-15' ),
-- FÓRMULA 7 (Cita ID 16: 2025-10-25 - Felipe Silva)
( (SELECT id_cita FROM citas WHERE id_paciente = '1000000027' AND fecha = '2025-10-25'), '2025-10-25' ),
-- FÓRMULA 8 (Cita ID 19: 2025-10-18 - Isabella Núñez)
( (SELECT id_cita FROM citas WHERE id_paciente = '1000000030' AND fecha = '2025-10-18'), '2025-10-18' );






-- *** 2. INSERCIÓN DE DETALLE_FORMULA  ***

INSERT INTO detalle_formula (id_formula, id_medicamento, cantidad, dosis)
VALUES
-- FÓRMULA 1 (Paracetamol)
(
    (SELECT id_formula FROM formulas WHERE id_cita = (SELECT id_cita FROM citas WHERE id_paciente = '1000000003' AND fecha = '2025-10-15')),
    (SELECT id_medicamento FROM medicamentos WHERE nombre_medicamento = 'Paracetamol Jarabe'), -- ¡CORREGIDO!
    1, '5ml cada 6 horas por 24 horas.'
),

-- FÓRMULA 2 (Ibuprofeno)
(
    (SELECT id_formula FROM formulas WHERE id_cita = (SELECT id_cita FROM citas WHERE id_paciente = '1000000014' AND fecha = '2025-10-10')),
    (SELECT id_medicamento FROM medicamentos WHERE nombre_medicamento = 'Ibuprofeno 400mg'), -- ¡CORREGIDO!
    20, 'Tomar 1 tableta cada 8 horas, solo si hay dolor.'
),

-- FÓRMULA 3 (Meloxicam y Omeprazol)
(
    (SELECT id_formula FROM formulas WHERE id_cita = (SELECT id_cita FROM citas WHERE id_paciente = '1000000017' AND fecha = '2025-10-14')),
    (SELECT id_medicamento FROM medicamentos WHERE nombre_medicamento = 'Meloxicam 15mg'), -- ¡CORREGIDO!
    15, 'Tomar 1 tableta diaria en ayunas.'
),
(
    (SELECT id_formula FROM formulas WHERE id_cita = (SELECT id_cita FROM citas WHERE id_paciente = '1000000017' AND fecha = '2025-10-14')),
    (SELECT id_medicamento FROM medicamentos WHERE nombre_medicamento = 'Omeprazol 20mg'), -- ¡CORREGIDO!
    30, 'Tomar 1 tableta antes de dormir.'
),

-- FÓRMULA 4 (Montelukast)
(
    (SELECT id_formula FROM formulas WHERE id_cita = (SELECT id_cita FROM citas WHERE id_paciente = '1000000020' AND fecha = '2025-10-05')),
    (SELECT id_medicamento FROM medicamentos WHERE nombre_medicamento = 'Montelukast 10mg'), -- ¡CORREGIDO!
    30, 'Tomar 1 tableta diaria en las noches.'
),

-- FÓRMULA 6 (Loratadina)
(
    (SELECT id_formula FROM formulas WHERE id_cita = (SELECT id_cita FROM citas WHERE id_paciente = '1000000024' AND fecha = '2025-10-15')),
    (SELECT id_medicamento FROM medicamentos WHERE nombre_medicamento = 'Loratadina 10mg'), -- ¡CORREGIDO!
    15, 'Tomar 1 tableta diaria.'
),

-- FÓRMULA 7 (Captopril)
(
    (SELECT id_formula FROM formulas WHERE id_cita = (SELECT id_cita FROM citas WHERE id_paciente = '1000000027' AND fecha = '2025-10-25')),
    (SELECT id_medicamento FROM medicamentos WHERE nombre_medicamento = 'Captopril 25mg'), -- ¡CORREGIDO!
    30, 'Tomar media tableta diaria.'
),

-- FÓRMULA 8 (Simvastatina)
(
    (SELECT id_formula FROM formulas WHERE id_cita = (SELECT id_cita FROM citas WHERE id_paciente = '1000000030' AND fecha = '2025-10-18')),
    (SELECT id_medicamento FROM medicamentos WHERE nombre_medicamento = 'Simvastatina 40mg'), -- ¡CORREGIDO!
    30, 'Tomar 1 tableta por la noche.'
);



[
  {
    "username": "antonio",
    "password": "1234",
    "roles": ["ADMINISTRADOR"]
  },
  {
    "username": "ivan",
    "password": "1234",
    "roles": ["MEDICO"]
  },
  {
    "username": "cristian",
    "password": "1234",
    "roles": ["PACIENTE"]
  },
  {
    "username": "jorge",
    "password": "1234",
    "roles": ["MEDICO"]
  }
]

